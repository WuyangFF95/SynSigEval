
#' Combine results for multiple datasets, from one computational approaches.
#'
#' Summarize results from each computational approach in \code{toolPath}/\code{datasetNames}
#' and combine them into \code{out.dir}.
#'
#' @param datasetNames Names of datasets which are also folder names
#' under \code{toolPath}. These folders contain results of \code{toolName}
#' on such datasets.
#' E.g. \code{SynSigGen::SBS1SBS5datasetNames}
#'
#' @param datasetGroup Numeric or character vector differentiating
#' datasets within each group.
#' E.g. For SBS1-SBS5 correlated datasets, we can consider the value of
#' SBS1-SBS5 exposure ratio as the value for \code{datsetgroup}:
#' \code{rep(c(0.1,0.5,1,2,5,10),each = 4)}
#'
#' The value is set to \code{Default} if unspecified.
#'
#'
#' @param datasetGroupName Meaning of all datasetGroup.
#' E.g. For SBS1-SBS5 correlated datasets, we can consider
#' \code{"SBS1-SBS5 exposure ratio"}
#' as what \code{datasetGroup} is referring to.
#'
#' @param datasetSubGroup Numeric or character vector differentiating
#' datasets within each sub-group.
#' E.g. For SBS1-SBS5 correlated datasets, we can consider the value of
#' \code{SBS1-SBS5 correlation} as the value of \code{subgroup}:
#' \code{rep(c(0.1,0.2,0.3,0.6),times = 5)}
#'
#' @param datasetSubGroupName Meaning of all \code{datasetSubGroup}.
#' E.g. For SBS1-SBS5 correlated datasets, we can consider
#' \code{"SBS1-SBS5 correlation"}
#' as what \code{datasetSubGroup} is referring to.
#'
#' @param toolName Name of computational approach to be investigated
#' (e.g. "SigProExtractor")
#'
#' @param toolPath The path of the results of the computational approach
#' to be investigated. May include top-level directory
#' (e.g. \code{3a.Original_output_K_unspecified}) and second-level
#' directory containing outputs and summaries of one computational approach
#' to be investigated (e.g. \code{SigProExtractor} or \code{SigProExtractor.results}).
#'
#' One example: \code{3a.Original_output_K_unspecified/SigProExtractor}
#'
#' Note: this function expects file \code{multiRun.RDa} generated by
#' \code{SummarizeMultiRuns} under \code{toolPath}/\code{datasetNames}
#'
#' @param out.dir Path of the output directory.
#'
#' @param display.datasetName Whether to put the name of spectra datasets inside of
#' the csv outputs of summary tables.
#'
#' @param overwrite Whether to overwrite the contents in out.dir if
#' it already exists. (Default: FALSE)
#'
#' @importFrom rlang .data
#'
#' @importFrom utils write.csv
#'
#' @export
#'
SummarizeOneToolMultiDatasets <-
  function(datasetNames = SynSigGen::SBS1SBS5datasetNames,
           datasetGroup,
           datasetGroupName,
           datasetSubGroup = NULL,
           datasetSubGroupName = NULL,
           toolName,
           toolPath,
           out.dir,
           display.datasetName = FALSE,
           overwrite = FALSE){

    ## Create output directory
    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exists")
    } else {
      dir.create(out.dir, recursive = T)
    }

    ## Wrap all datasets into one group, if datasetGroup is NULL.
    ## Re-order the dataset.group for better visualization of
    ## ggplot facets.
    {
      if(is.null(datasetGroup))
        datasetGroup <- rep("Default",length(datasetNames))
      datasetGroup <- factor(
        datasetGroup,
        levels = gtools::mixedsort(unique(datasetGroup)))
      names(datasetGroup) <- datasetNames

      if(!exists("datasetSubGroup"))
        datasetSubGroup <- datasetNames
      datasetSubGroup <- factor(
        datasetSubGroup,
        levels = gtools::mixedsort(unique(datasetSubGroup)))
      names(datasetSubGroup) <- datasetNames
    }

    ## Calculate summary tables for measures of extraction performance
    ## Need to calculate tables for All 6 measures
    {
      indexes <- c("averCosSim","falseNeg","falsePos",
                   "truePos","TPR","PPV")
      indexLabels <- c("averCosSim" = "Average cosine similarity of all signatures",
                       "falseNeg" = "False negatives",
                       "falsePos" = "False positives",
                       "truePos" = "True positives",
                       "TPR" = "True positive rate (TPR, sensitivity)",
                       "PPV" = "Positive predictive value (PPV, precision)")
      subtitles <- c("averCosSim" = "",
                     "falseNeg" = "Number of missing ground-truth signatures",
                     "falsePos" = "Number of artefact signatures extracted, but different from ground-truth signatures",
                     "truePos" = "Number of extracted ground-truth signatures",
                     "TPR" = "True Positives / (True Positives + False Negatives)",
                     "PPV" = "True Positives / (True Positives + False Positives)")
      names(indexLabels) <- indexes
      names(subtitles) <- indexes
      indexNums <- length(indexes)

      ## Construct a summary list for storage
      OneToolSummary <- list()

      ## Combine each measurement for extraction performance for multiple datasets
      ## in multiple runs onto one summary table:
      for(datasetName in datasetNames){
        thirdLevelDir <- paste0(toolPath,"/",datasetName)
        toolName <- strsplit(basename(toolPath),".results")[[1]]
        ## Add multiRun <- NULL to please R check
        multiRun <- NULL
        load(paste0(thirdLevelDir,"/multiRun.RDa"))
        for(index in indexes){
          measure4OneDataset <- data.frame(seed = names(multiRun[[index]]),
                                           value = multiRun[[index]],
                                           toolName = toolName,
                                           datasetName = datasetName,
                                           datasetGroup = datasetGroup[datasetName],
                                           datasetSubGroup = datasetSubGroup[datasetName],
                                           stringsAsFactors = FALSE)
          rownames(measure4OneDataset) <- NULL

          ## Create a data.frame for each measure,
          ## and summarize multi-Run, multiDataset values
          ## for each measure.
          if(is.null(OneToolSummary[[index]])){
            OneToolSummary[[index]] <- data.frame()
          }
          OneToolSummary[[index]] <- rbind(OneToolSummary[[index]],measure4OneDataset)
        }
      }

      ## Calculate the stats (returned by summary()) of each extraction performance measure.
      OneToolSummary$stats <- list()
      for(index in indexes){
        currentStats <- summary(OneToolSummary[[index]][,"value"])
        OneToolSummary$stats[[index]] <- currentStats
      }

      ## For TPR (sensitivity), PPV and Number of False Negatives,
      ## calculate the proportion of 1.
      OneToolSummary$prop1 <- list()
      for(index in c("TPR","PPV","falseNeg")){
        currentProp <- length(which(OneToolSummary[[index]][,"value"] == 1)) / length(OneToolSummary[[index]][,"value"])
        OneToolSummary$prop1[[index]] <- currentProp
      }


    }

    ## Draw violin + beeswarm plot for extraction measures
    {
      ## Create a list to store ggplot2 violin + beeswarm plot objects
      ggplotList <- list()
      ## Plot a value~datasetSubGroup beeswarm for each measure.
      for(index in indexes){
        indexNum <- which(indexes == index)
        ## ggplot2::ggplot() sets coordinates
        ggplotList[[index]] <- ggplot2::ggplot(
          OneToolSummary[[index]],
          ## Make sure that only one x-label is shown in one small facet.
          #ggplot2::aes(x = .data$datasetGroup, y = .data$value)
          ggplot2::aes(x = .data$toolName, y = .data$value)
        )
        ## Add facets
        ggplotList[[index]] <- ggplotList[[index]] +
          ggplot2::facet_grid(
            rows = ggplot2::vars(datasetSubGroup),
            cols = ggplot2::vars(datasetGroup),
            ## Move x facet labels to the right,
            ## This is to let the facet labels correspond to axis.title.
            switch = "x") +
          ## Draw violin and beeswarm plots on multi-facets.
          ## Draw geom_violin
          ggplot2::geom_violin(
            ## Change filling color to white
            fill = "#FFFFFF",
            ## Maximize the violin plot width
            scale = "width"
          ) +
          ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
          ## Show mean of the extraction meaasure distribution, as a blue diamond.
          ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
          ## Draw beeswarm plot
          ggbeeswarm::geom_quasirandom(groupOnX = TRUE,
                                       ## Make dot size smaller
                                       size = 0.3
                                       #,
                                       ## Remove differentiated colors for beeswarm dots
                                       ## Set groups for the filling functionalities to differentiate
                                       #ggplot2::aes(color = .data$datasetGroup)
          ) +
          ## Change filling color
          ggplot2::scale_fill_brewer(palette = "Greys") +
          ## Change titles
          ## and change axis titles.
          ## ggplot2::labs() has stronger function than ggplo2::ggtitle.
          ggplot2::labs(
            ## Add title for value~datasetSubGroup beeswarm plot,
            title = paste0(toolName,": ",indexLabels[index]),
            subtitle = subtitles[index],
            ## Change title of y axis (axis.title.y) into measure info (same as title)
            y = indexLabels[index],
            ## Change title of x axis to "Pearson's R squared"
            x = "Pearson's R squared") +
          ## Change title of legend to datasetGroupName
          ggplot2::guides(color = ggplot2::guide_legend(title = datasetGroupName)) +
          ## Change axis.text and tickmarks
          ggplot2::theme(
            ## Remove axis.text.x
            axis.text.x = ggplot2::element_blank(),
            ## Remove tick marks on x axis (axis.ticks.x)
            axis.ticks.x = ggplot2::element_blank(),
            ## Remove entire legend
            legend.position = "none"
          ) +
          ## Restrict the decimal numbers of values of measures (y) to be 2
          ggplot2::scale_y_continuous(
            labels =function(x) sprintf("%.2f", x),
            ## Add a secondary axis title on the top of the plot
            ## Showing axis label indicating facets
            sec.axis = ggplot2::dup_axis(
              breaks = NULL, ## Don't show axis breaks
              labels = NULL, ## Don't show axis tickmarks
              name = "SBS1:SBS5 mutation count ratio")
          )
      }


      ## Output multiple extraction measures in a pdf file
      grDevices::pdf(paste0(out.dir,"/extraction.measures.pdf"), pointsize = 1)
      for(index in indexes)
        suppressMessages(suppressWarnings(print(ggplotList[[index]])))
      grDevices::dev.off()
    }


    ## Summarize cosine similarity to each ground-truth signature
    ## and number of extracted signatures similar to each ground-truth
    ## signature for one tool.
    {
      OneToolSummary$cosSim <- list()
      OneToolSummary$NumSigsSimilar <- list()

      ## Combine one-signature cosine similarity from different spectra datasets
      for(datasetName in datasetNames){
        thirdLevelDir <- paste0(toolPath,"/",datasetName)
        toolName <- strsplit(basename(toolPath),".results")[[1]]
        ## Add multiRun <- NULL to please R check
        multiRun <- NULL
        load(paste0(thirdLevelDir,"/multiRun.RDa"))
        gtSigNames <- names(multiRun$cosSim)
        sigNums <- length(gtSigNames)

        for(measure in c("cosSim","NumSigsSimilar")){
          for(gtSigName in gtSigNames){

            gtMeasure4OneDataset <- data.frame(seed = names(multiRun[[measure]][[gtSigName]]),
                                               value = multiRun[[measure]][[gtSigName]],
                                               toolName = toolName,
                                               datasetName = datasetName,
                                               datasetGroup = datasetGroup[datasetName],
                                               datasetSubGroup = datasetSubGroup[datasetName],
                                               stringsAsFactors = FALSE)
            rownames(gtMeasure4OneDataset) <- NULL

            ## Create a data.frame for each measure,
            ## and summarize multi-Run, multiDataset values
            ## for each measure.
            if(is.null(OneToolSummary[[measure]][[gtSigName]])){
              OneToolSummary[[measure]][[gtSigName]] <- data.frame()
            }
            OneToolSummary[[measure]][[gtSigName]] <- rbind(OneToolSummary[[measure]][[gtSigName]],gtMeasure4OneDataset)
          }
        }
      }

      ## Calculate the stats (returned by summary()) of cosine similarity to each
      ## ground-truth signature and
      ## number of signatures similar to each ground-truth signature.
      for(measure in c("cosSim","NumSigsSimilar")){
        OneToolSummary$stats[[measure]] <- list()
        for(gtSigName in gtSigNames){
          currentStats <- summary(OneToolSummary[[measure]][[gtSigName]][,"value"])
          OneToolSummary$stats[[measure]][[gtSigName]] <- currentStats
        }
      }


      ## Combine multiple one-signature cosine similarity data.frame
      ## into OneToolSummary$cosSim$combined
      OneToolSummary$cosSim$combined <- data.frame()
      OneToolSummary$NumSigsSimilar$combined <- data.frame()
      for(measure in c("cosSim","NumSigsSimilar")){
        for(gtSigName in gtSigNames){
          gtMeasure4AllDatasets <- data.frame(OneToolSummary[[measure]][[gtSigName]],
                                              stringsAsFactors = FALSE)
          rownames(gtMeasure4AllDatasets) <- NULL

          if(nrow(OneToolSummary[[measure]]$combined) == 0 |
             ncol(OneToolSummary[[measure]]$combined) == 0 |
             is.null(dim(OneToolSummary[[measure]]$combined)) ) {
            OneToolSummary[[measure]]$combined <- gtMeasure4AllDatasets
          } else {
            OneToolSummary[[measure]]$combined <-
              rbind(OneToolSummary[[measure]]$combined,gtMeasure4AllDatasets)
          }
        }
      }
    }


    ## Plot one-signature cosine similarity violin + beeswarm plot for one tool
    { ## debug
      ## Create a list to store ggplot2 violin + beeswarm plot objects
      ggplotList$cosSim <- list()
      ## Plot a value~datasetSubGroup beeswarm plot for each signature.
      for(gtSigName in gtSigNames){
        sigNum <- which(gtSigNames == gtSigName)
        ggplotList$cosSim[[gtSigName]] <- ggplot2::ggplot(
          OneToolSummary$cosSim[[gtSigName]],
          ## Make sure that only one x-label is shown in one small facet.
          #ggplot2::aes(x = .data$datasetGroup, y = .data$value)
          ggplot2::aes(x = .data$toolName, y = .data$value)
        )
        ## Add facets
        ggplotList$cosSim[[gtSigName]] <- ggplotList$cosSim[[gtSigName]] +
          ggplot2::facet_grid(
            rows = ggplot2::vars(datasetSubGroup),
            cols = ggplot2::vars(datasetGroup),
            ## Move x facet labels to the right,
            ## This is to let the facet labels correspond to axis.title.
            switch = "x") +
          ## Draw beeswarm plots on multiple facets
          ## Draw geom_violin
          ggplot2::geom_violin(
            ## Change filling color to white
            fill = "#FFFFFF",
            ## Maximize the violin plot width
            scale = "width",
            ## Hide outliers
            #outlier.shape = NA
          ) +
          ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
          ## Show mean of the extraction meaasure distribution, as a blue diamond.
          ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
          ## Draw beeswarm plot
          ggbeeswarm::geom_quasirandom(groupOnX = TRUE,
                                       size = 0.3 ## Make dot size smaller
                                       #,
                                       ## Remove differentiated colors for beeswarm dots
                                       ## Set groups for the filling functionalities to differentiate
                                       #ggplot2::aes(color = .data$datasetGroup)
          ) +
          ## Change filling color
          ggplot2::scale_fill_brewer(palette = "Greys") +
          ## Change axis.text and tickmarks
          ggplot2::theme(
            ## Remove axis.text.x
            axis.text.x = ggplot2::element_blank(),
            ## Remove tick marks on x axis (axis.ticks.x)
            axis.ticks.x = ggplot2::element_blank(),
            ## Remove entire legend
            legend.position = "none"
          ) +
          ## Add titles
          ggplot2::labs(
            ## Add title for value~datasetSubGroup beeswarm plot
            title = paste0(toolName,": Average cosine similarity between signature ",gtSigName),
            subtitle = paste0("and all extracted signatures resembling ",gtSigName),
            ## Change title of y axis (axis.title.y) into gtSigName info (same as title)
            y = paste0("Cosine similarity to signature ",gtSigName),
            ## Change title of x axis to "Pearson's R squared"
            x = "Pearson's R squared") +
          ## Change title of legend to datasetGroupName
          ggplot2::guides(color = ggplot2::guide_legend(title = datasetGroupName)) +
          ## Restrict the decimal numbers of values of measures (y) to be 2
          ggplot2::scale_y_continuous(
            ## For one-signature cosine similarity, set ylim from the minimum of Manhattan distance value to 1.
            limits = c(min(OneToolSummary$cosSim$combined$value),1),
            labels =function(x) sprintf("%.2f", x),
            ## Add a secondary axis title on the top of the plot
            ## Showing axis label indicating facets
            sec.axis = ggplot2::dup_axis(
              breaks = NULL, ## Don't show axis breaks
              labels = NULL, ## Don't show axis tickmarks
              name = "SBS1:SBS5 mutation count ratio"))
      }


      ## Output multiple extraction measures in a pdf file
      grDevices::pdf(paste0(out.dir,"/onesig.cossim.pdf"), pointsize = 1)
      for(gtSigName in gtSigNames)
        suppressMessages(suppressWarnings(print(ggplotList$cosSim[[gtSigName]])))
      grDevices::dev.off()
    }


    ## Summarize scaled Manhattan distance only if
    ## scaled Manhattan distance data exists in object multRun
    exposureFlag <- TRUE
    {
      for(datasetName in datasetNames){
        thirdLevelDir <- paste0(toolPath,"/",datasetName)
        toolName <- strsplit(basename(toolPath),".results")[[1]]
        ## Add multiRun <- NULL to please R check
        multiRun <- NULL
        load(paste0(thirdLevelDir,"/multiRun.RDa"))
        if(is.null(multiRun$AggManhattanDist)){
          exposureFlag <- FALSE
          message("Skip summarizing scaled Manhattan distance...\n")
          break
        }
      }
    }

    ## Summarize aggregated scaled Manhattan distance for one tool.
    if(exposureFlag){
      ## Summarize aggregated scaled Manhattan distance for one tool.
      {
        OneToolSummary$AggManhattanDist <- list()

        for(datasetName in datasetNames){
          thirdLevelDir <- paste0(toolPath,"/",datasetName)
          toolName <- strsplit(basename(toolPath),".results")[[1]]
          ## Add multiRun <- NULL to please R check
          multiRun <- NULL
          load(paste0(thirdLevelDir,"/multiRun.RDa"))

          for(gtSigName in gtSigNames){

            gtAggManhattanDist4OneDataset <- data.frame(seed = colnames(multiRun$AggManhattanDist),
                                                        value = multiRun$AggManhattanDist[gtSigName,],
                                                        toolName = toolName,
                                                        datasetName = datasetName,
                                                        datasetGroup = datasetGroup[datasetName],
                                                        datasetSubGroup = datasetSubGroup[datasetName],
                                                        stringsAsFactors = FALSE)

            rownames(gtAggManhattanDist4OneDataset) <- NULL

            ## Create a data.frame for each measure,
            ## and summarize multi-Run, multiDataset values
            ## for each measure.
            if(is.null(OneToolSummary$AggManhattanDist[[gtSigName]])){
              OneToolSummary$AggManhattanDist[[gtSigName]] <- data.frame()
            }
            OneToolSummary$AggManhattanDist[[gtSigName]] <- rbind(OneToolSummary$AggManhattanDist[[gtSigName]],gtAggManhattanDist4OneDataset)
          }
        }

        ## Combine multiple ground-truth signature Manhattan-distance data.frame
        ## into OneToolSummary$AggManhattanDist$combined.
        OneToolSummary$AggManhattanDist$combined <- data.frame()
        for(gtSigName in gtSigNames){
          gtAggManhattanDist4AllDatasets <- data.frame(OneToolSummary$AggManhattanDist[[gtSigName]],
                                                       stringsAsFactors = FALSE)
          rownames(gtAggManhattanDist4AllDatasets) <- NULL

          if(nrow(OneToolSummary$AggManhattanDist$combined) == 0 |
             ncol(OneToolSummary$AggManhattanDist$combined) == 0 |
             is.null(dim(OneToolSummary$AggManhattanDist$combined)) ) {
            OneToolSummary$AggManhattanDist$combined <- gtAggManhattanDist4AllDatasets
          } else {
            OneToolSummary$AggManhattanDist$combined <-
              rbind(OneToolSummary$AggManhattanDist$combined,gtAggManhattanDist4AllDatasets)
          }
        }

      }
      ## Plot aggregated scaled Manhattan distance violin plot
      ## + beeswarm plot for one tool
      { ## debug
        ## Create a list to store ggplot2 violin + beeswarm plot objects
        ggplotList$AggManhattanDist <- list()
        ## Plot a value~datasetSubGroup beeswarm plot for each signature.
        for(gtSigName in gtSigNames){
          sigNum <- which(gtSigNames == gtSigName)
          ggplotList$AggManhattanDist[[gtSigName]] <- ggplot2::ggplot(
            OneToolSummary$AggManhattanDist[[gtSigName]],
            ## Make sure that only one x-label is shown in one small facet.
            #ggplot2::aes(x = .data$datasetGroup, y = .data$value)
            ggplot2::aes(x = .data$toolName, y = .data$value)
          )
          ## Add facets
          ggplotList$AggManhattanDist[[gtSigName]] <- ggplotList$AggManhattanDist[[gtSigName]] +
            ggplot2::facet_grid(
              rows = ggplot2::vars(datasetSubGroup),
              cols = ggplot2::vars(datasetGroup),
              ## Move x facet labels to the right,
              ## This is to let the facet labels correspond to axis.title.
              switch = "x") +
            ## Draw beeswarm plots on multiple facets
            ## Draw geom_violin
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              ## Maximize the violin plot width
              scale = "width",
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
            ## Draw beeswarm plot
            ggbeeswarm::geom_quasirandom(groupOnX = TRUE,
                                         size = 0.3 ## Make dot size smaller
                                         ,
                                         ## Remove differentiated colors for beeswarm dots
                                         ## Set groups for the filling functionalities to differentiate
                                         #ggplot2::aes(color = .data$datasetGroup)
            ) +
            ## Change filling color
            ggplot2::scale_fill_brewer(palette = "Greys") +
            ## Change axis.text and tickmarks
            ggplot2::theme(
              ## Remove axis.text.x
              axis.text.x = ggplot2::element_blank(),
              ## Remove tick marks on x axis (axis.ticks.x)
              axis.ticks.x = ggplot2::element_blank(),
              ## Remove entire legend
              legend.position = "none"
            ) +
            ## Change titles
            ggplot2::labs(
              ## Add title for value~datasetSubGroup beeswarm plot
              title = paste0(toolName,": Scaled Manhattan distance of ",gtSigName," exposure"),
              subtitle = "Between ground-truth exposure and inferred exposure",
              ## Change title of y axis (axis.title.y) same as gtSigName info (same as title)
              y = paste0("Scaled aggregated Manhattan distance of ",gtSigName," exposure"),
              ## Change title of x axis to "Pearson's R squared"
              x = "Pearson's R squared") +
            ## Change title of legend to datasetGroupName
            ggplot2::guides(color = ggplot2::guide_legend(title = datasetGroupName)) +
            ## Restrict the decimal numbers of values of measures (y) to be 2
            ggplot2::scale_y_continuous(
              ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
              limits = c(0,max(OneToolSummary$AggManhattanDist$combined$value)),
              ## Restrict the decimal numbers of values of measures (y) to be 2
              labels =function(x) sprintf("%.2f", x),
              ## Add a secondary axis title on the top of the plot
              ## Showing axis label indicating facets
              sec.axis = ggplot2::dup_axis(
                breaks = NULL, ## Don't show axis breaks
                labels = NULL, ## Don't show axis tickmarks
                name = "SBS1:SBS5 mutation count ratio"))
        }


        ## Output multiple extraction measures in a pdf file
        grDevices::pdf(paste0(out.dir,"/aggregated.Manhattan.dist.pdf"), pointsize = 1)
        for(gtSigName in gtSigNames)
          suppressMessages(suppressWarnings(print(ggplotList$AggManhattanDist[[gtSigName]])))
        grDevices::dev.off()
      }
    }


    ## Summarize mean of scaled Manhattan distance
    ## separated for individual tumors for each tool.
    if(exposureFlag){
      {
        OneToolSummary$meanSepMD <- list()

        for(datasetName in datasetNames){
          thirdLevelDir <- paste0(toolPath,"/",datasetName)
          toolName <- strsplit(basename(toolPath),".results")[[1]]
          ## Add multiRun <- NULL to please R check
          multiRun <- NULL
          load(paste0(thirdLevelDir,"/multiRun.RDa"))

          for(gtSigName in gtSigNames){

            gtmeanSepMD4OneDataset <- data.frame(seed = colnames(multiRun$meanSepMD),
                                                 value = multiRun$meanSepMD[gtSigName,],
                                                 toolName = toolName,
                                                 datasetName = datasetName,
                                                 datasetGroup = datasetGroup[datasetName],
                                                 datasetSubGroup = datasetSubGroup[datasetName],
                                                 stringsAsFactors = FALSE)

            rownames(gtmeanSepMD4OneDataset) <- NULL

            ## Create a data.frame for each measure,
            ## and summarize multi-Run, multiDataset values
            ## for each measure.
            if(is.null(OneToolSummary$meanSepMD[[gtSigName]])){
              OneToolSummary$meanSepMD[[gtSigName]] <- data.frame()
            }
            OneToolSummary$meanSepMD[[gtSigName]] <- rbind(OneToolSummary$meanSepMD[[gtSigName]],gtmeanSepMD4OneDataset)
          }
        }

        OneToolSummary$meanSepMD$combined <- data.frame()
        for(gtSigName in gtSigNames){
          gtmeanSepMD4AllDatasets <- data.frame(OneToolSummary$meanSepMD[[gtSigName]],
                                                stringsAsFactors = FALSE)
          rownames(gtmeanSepMD4AllDatasets) <- NULL

          if(nrow(OneToolSummary$meanSepMD$combined) == 0 |
             ncol(OneToolSummary$meanSepMD$combined) == 0 |
             is.null(dim(OneToolSummary$meanSepMD$combined)) ) {
            OneToolSummary$meanSepMD$combined <- gtmeanSepMD4AllDatasets
          } else {
            OneToolSummary$meanSepMD$combined <-
              rbind(OneToolSummary$meanSepMD$combined,gtmeanSepMD4AllDatasets)
          }
        }

      }
      ## Plot mean of separated scaled Manhattan distance violin plot
      ## + beeswarm plot for one tool
      { ## debug
        ## Create a list to store ggplot2 violin + beeswarm plot objects
        ggplotList$meanSepMD <- list()
        ## Plot a value~datasetSubGroup beeswarm plot for each signature.
        for(gtSigName in gtSigNames){
          sigNum <- which(gtSigNames == gtSigName)
          ggplotList$meanSepMD[[gtSigName]] <- ggplot2::ggplot(
            OneToolSummary$meanSepMD[[gtSigName]],
            ## Make sure that only one x-label is shown in one small facet.
            #ggplot2::aes(x = .data$datasetGroup, y = .data$value)
            ggplot2::aes(x = .data$toolName, y = .data$value)
          )
          ## Add facets
          ggplotList$meanSepMD[[gtSigName]] <- ggplotList$meanSepMD[[gtSigName]] +
            ggplot2::facet_grid(
              rows = ggplot2::vars(datasetSubGroup),
              cols = ggplot2::vars(datasetGroup),
              ## Move x facet labels to the right,
              ## This is to let the facet labels correspond to axis.title.
              switch = "x") +
            ## Draw beeswarm plots on multiple facets
            ## Draw geom_violin
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              ## Maximize the violin plot width
              scale = "width",
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
            ## Draw beeswarm plot
            ggbeeswarm::geom_quasirandom(groupOnX = TRUE,
                                         size = 0.3 ## Make dot size smaller
                                         ,
                                         ## Remove differentiated colors for beeswarm dots
                                         ## Set groups for the filling functionalities to differentiate
                                         #ggplot2::aes(color = .data$datasetGroup)
            ) +
            ## Change filling color
            ggplot2::scale_fill_brewer(palette = "Greys") +
            ## Change axis.text and tickmarks
            ggplot2::theme(
              ## Remove axis.text.x
              axis.text.x = ggplot2::element_blank(),
              ## Remove tick marks on x axis (axis.ticks.x)
              axis.ticks.x = ggplot2::element_blank(),
              ## Remove entire legend
              legend.position = "none"
            ) +
            ## Change titles
            ggplot2::labs(
              title = paste0(toolName,": Mean of scaled Manhattan distance of "),
              subtitle = paste0(gtSigName," exposure in individual tumors"),
              ## Change title of y axis (axis.title.y) same as gtSigName info (same as title)
              y = paste0("mean(separated Manhattan distance of ",gtSigName," exposure)"),
              ## Change title of x axis to "Pearson's R squared"
              x = "Pearson's R squared") +
            ## Change title of legend to datasetGroupName
            ggplot2::guides(color = ggplot2::guide_legend(title = datasetGroupName)) +
            ## Restrict the decimal numbers of values of measures (y) to be 2
            ggplot2::scale_y_continuous(
              ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
              limits = c(0,max(OneToolSummary$meanSepMD$combined$value)),
              ## Restrict the decimal numbers of values of measures (y) to be 2
              labels =function(x) sprintf("%.2f", x),
              ## Add a secondary axis title on the top of the plot
              ## Showing axis label indicating facets
              sec.axis = ggplot2::dup_axis(
                breaks = NULL, ## Don't show axis breaks
                labels = NULL, ## Don't show axis tickmarks
                name = "SBS1:SBS5 mutation count ratio"))
        }


        ## Output multiple extraction measures in a pdf file
        grDevices::pdf(paste0(out.dir,"/mean.of.sep.Scaled.Manhattan.dist.pdf"), pointsize = 1)
        for(gtSigName in gtSigNames)
          suppressMessages(suppressWarnings(print(ggplotList$meanSepMD[[gtSigName]])))
        grDevices::dev.off()
      }
    }


    ## Summarize standard deviation of scaled Manhattan distance
    ## separated for individual tumors for each tool.
    if(exposureFlag){
      {
        OneToolSummary$sdSepMD <- list()

        for(datasetName in datasetNames){
          thirdLevelDir <- paste0(toolPath,"/",datasetName)
          toolName <- strsplit(basename(toolPath),".results")[[1]]
          ## Add multiRun <- NULL to please R check
          multiRun <- NULL
          load(paste0(thirdLevelDir,"/multiRun.RDa"))

          for(gtSigName in gtSigNames){

            gtsdSepMD4OneDataset <- data.frame(seed = colnames(multiRun$sdSepMD),
                                               value = multiRun$sdSepMD[gtSigName,],
                                               toolName = toolName,
                                               datasetName = datasetName,
                                               datasetGroup = datasetGroup[datasetName],
                                               datasetSubGroup = datasetSubGroup[datasetName],
                                               stringsAsFactors = FALSE)

            rownames(gtsdSepMD4OneDataset) <- NULL

            ## Create a data.frame for each measure,
            ## and summarize multi-Run, multiDataset values
            ## for each measure.
            if(is.null(OneToolSummary$sdSepMD[[gtSigName]])){
              OneToolSummary$sdSepMD[[gtSigName]] <- data.frame()
            }
            OneToolSummary$sdSepMD[[gtSigName]] <- rbind(OneToolSummary$sdSepMD[[gtSigName]],gtsdSepMD4OneDataset)
          }
        }

        OneToolSummary$sdSepMD$combined <- data.frame()
        for(gtSigName in gtSigNames){
          gtsdSepMD4AllDatasets <- data.frame(OneToolSummary$sdSepMD[[gtSigName]],
                                              stringsAsFactors = FALSE)
          rownames(gtsdSepMD4AllDatasets) <- NULL

          if(nrow(OneToolSummary$sdSepMD$combined) == 0 |
             ncol(OneToolSummary$sdSepMD$combined) == 0 |
             is.null(dim(OneToolSummary$sdSepMD$combined)) ) {
            OneToolSummary$sdSepMD$combined <- gtsdSepMD4AllDatasets
          } else {
            OneToolSummary$sdSepMD$combined <-
              rbind(OneToolSummary$sdSepMD$combined,gtsdSepMD4AllDatasets)
          }
        }

      }
      ## Plot standard deviation of separated scaled Manhattan distance
      ## violin plot + beeswarm plot for one tool
      { ## debug
        ## Create a list to store ggplot2 violin + beeswarm plot objects
        ggplotList$sdSepMD <- list()
        ## Plot a value~datasetSubGroup beeswarm plot for each signature.
        for(gtSigName in gtSigNames){
          sigNum <- which(gtSigNames == gtSigName)
          ggplotList$sdSepMD[[gtSigName]] <- ggplot2::ggplot(
            OneToolSummary$sdSepMD[[gtSigName]],
            ## Make sure that only one x-label is shown in one small facet.
            #ggplot2::aes(x = .data$datasetGroup, y = .data$value)
            ggplot2::aes(x = .data$toolName, y = .data$value)
          )
          ## Add facets
          ggplotList$sdSepMD[[gtSigName]] <- ggplotList$sdSepMD[[gtSigName]] +
            ggplot2::facet_grid(
              rows = ggplot2::vars(datasetSubGroup),
              cols = ggplot2::vars(datasetGroup),
              ## Move x facet labels to the right,
              ## This is to let the facet labels correspond to axis.title.
              switch = "x") +
            ## Draw beeswarm plots on multiple facets
            ## Draw geom_violin
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              ## Maximize the violin plot width
              scale = "width",
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
            ## Draw beeswarm plot
            ggbeeswarm::geom_quasirandom(groupOnX = TRUE,
                                         size = 0.3 ## Make dot size smaller
                                         ,
                                         ## Remove differentiated colors for beeswarm dots
                                         ## Set groups for the filling functionalities to differentiate
                                         #ggplot2::aes(color = .data$datasetGroup)
            ) +
            ## Change filling color
            ggplot2::scale_fill_brewer(palette = "Greys") +
            ## Change axis.text and tickmarks
            ggplot2::theme(
              ## Remove axis.text.x
              axis.text.x = ggplot2::element_blank(),
              ## Remove tick marks on x axis (axis.ticks.x)
              axis.ticks.x = ggplot2::element_blank(),
              ## Remove entire legend
              legend.position = "none"
            ) +
            ## Change titles
            ggplot2::labs(
              ## Add title for value~datasetSubGroup beeswarm plot
              title = paste0(toolName,": Standard deviation of scaled Manhattan distance of "),
              subtitle = paste0(gtSigName," exposure in individual tumors"),
              ## Change title of y axis (axis.title.y) same as gtSigName info (same as title)
              y = paste0("sd(separated Manhattan distance of ",gtSigName," exposure)"),
              ## Change title of x axis to "Pearson's R squared"
              x = "Pearson's R squared") +
            ## Change title of legend to datasetGroupName
            ggplot2::guides(color = ggplot2::guide_legend(title = datasetGroupName)) +
            ## Restrict the decimal numbers of values of measures (y) to be 2
            ggplot2::scale_y_continuous(
              ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
              limits = c(0,max(OneToolSummary$sdSepMD$combined$value)),
              ## Restrict the decimal numbers of values of measures (y) to be 2
              labels =function(x) sprintf("%.2f", x),
              ## Add a secondary axis title on the top of the plot
              ## Showing axis label indicating facets
              sec.axis = ggplot2::dup_axis(
                breaks = NULL, ## Don't show axis breaks
                labels = NULL, ## Don't show axis tickmarks
                name = "SBS1:SBS5 mutation count ratio"))
        }


        ## Output multiple extraction measures in a pdf file
        grDevices::pdf(paste0(out.dir,"/stdev.of.sep.Scaled.Manhattan.dist.pdf"), pointsize = 1)
        for(gtSigName in gtSigNames)
          suppressMessages(suppressWarnings(print(ggplotList$sdSepMD[[gtSigName]])))
        grDevices::dev.off()
      }
    }





    ## Write Summary tables for extraction measures
    for(index in indexes){
      output <- OneToolSummary[[index]]

      ## Change "value" to label of measure.
      colnames(output)[1] <- "Seed or run number"
      colnames(output)[2] <- indexLabels[index]
      colnames(output)[3] <- "Name of computational approach"
      colnames(output)[4] <- "Name of mutational spectra dataset"
      colnames(output)[5] <- datasetGroupName
      colnames(output)[6] <- datasetSubGroupName

      if(!display.datasetName){
        ## Delete the 4th column,
        ## which refers to the name of the corresponding
        ## spectra dataset.
        output <- output[,-4]
      }

      write.csv(output,
                file = paste0(out.dir,"/",index,".csv"),
                quote = F, row.names = F)
    }

    ## Write Summary tables for signature cosine similarity.
    for(gtSigName in gtSigNames){
      output <- OneToolSummary$cosSim[[gtSigName]]

      ## Change "value" to label of measure.
      colnames(output)[1] <- "Seed or run number"
      colnames(output)[2] <- paste0("Cosine similarity to ground-truth signature ",gtSigName)
      colnames(output)[3] <- "Name of computational approach"
      colnames(output)[4] <- "Name of mutational spectra dataset"
      colnames(output)[5] <- datasetGroupName
      colnames(output)[6] <- datasetSubGroupName

      if(!display.datasetName){
        ## Delete the 4th column,
        ## which refers to the name of the corresponding
        ## spectra dataset.
        output <- output[,-4]
      }

      write.csv(output,
                file = paste0(out.dir,"/cossim.to.",gtSigName,".csv"),
                quote = F, row.names = F)
    }

    ## Write Summary tables for number of extracted sigs similar to
    ## each ground-truth sig.
    for(gtSigName in gtSigNames){
      output <- OneToolSummary$NumSigsSimilar[[gtSigName]]

      ## Change "value" to label of measure.
      colnames(output)[1] <- "Seed or run number"
      colnames(output)[2] <- paste0("Number of software-reported signatures with ",
                                    "cosine similarity > 0.9 to ",gtSigName)
      colnames(output)[3] <- "Name of computational approach"
      colnames(output)[4] <- "Name of mutational spectra dataset"
      colnames(output)[5] <- datasetGroupName
      colnames(output)[6] <- datasetSubGroupName

      if(!display.datasetName){
        ## Delete the 4th column,
        ## which refers to the name of the corresponding
        ## spectra dataset.
        output <- output[,-4]
      }

      write.csv(output,
                file = paste0(out.dir,"/num.sigs.similar.to.",gtSigName,".csv"),
                quote = F, row.names = F)
    }


    ## Write stat summary information into a text file.
    utils::capture.output(OneToolSummary$stats,file = paste0(out.dir,"/stats.txt"))
    utils::capture.output(OneToolSummary$prop1,file = paste0(out.dir,"/prop1.txt"))


    ## Add datasetGroupName and datasetSubGroupName into OneToolSummary
    OneToolSummary$datasetGroupName <- datasetGroupName
    OneToolSummary$datasetSubGroupName <- datasetSubGroupName

    save(OneToolSummary, file = paste0(out.dir,"/OneToolSummary.RDa"))
    invisible(OneToolSummary)
  }
