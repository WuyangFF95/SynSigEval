#' Summarize results for multiple datasets, by different computational approaches.
#'
#' Summarize results of mutational signature extraction and exposure inferrence
#' by multiple computational approaches on multiple datasets. Before running this
#' function, make sure the summary file for each single data set
#'  \code{third.level.dir}/\code{multiTools.Rda} exists.
#'
#' \code{multiTools.Rda} is generated by \code{\link{SummarizeMultiToolsOneDataset}}).
#'
#' @param dataset.dirs Paths of top-level dataset directories trees you want
#' to investigate.
#' E.g. "./S.0.1.Rsq.0.1"
#'
#' @param second.third.level.dirname Name of the second.level.dir (e.g. "sp.sp")
#' and the third.level.dir (e.g. "ExtrAttr") to be investigated.
#'
#' Examples are: "sp.sp/ExtrAttr", "sa.sa.96/Attr"
#'
#' Note: \code{multiTools.RDa} are expected to be exist under
#' \code{dataset.dirs}/\code{second.third.level.dirname}.
#'
#' @param out.dir Path of the output directory.
#'
#' @param overwrite Whether to overwrite the contents in out.dir if
#' it already exists. (Default: FALSE)
#'
#' @importFrom rlang .data
#'
#' @importFrom utils write.csv
#'
#' @export
#'
SummarizeMultiToolsMultiDatasets <-
  function(dataset.dirs,
           second.third.level.dirname,
           out.dir,
           overwrite = FALSE){

    ## Create output directory
    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir, recursive = T)
    }

    ## For each measure,
    ## Create a data.frame integrating results of
    ## all runs and for all datasets
    {
      indexes <- c("averCosSim","falseNeg","falsePos",
                   "truePos","TPR","PPV")
      indexLabels <- c("averCosSim" = "Average cosine similarity of all signatures",
                       "falseNeg" = "False negatives",
                       "falsePos" = "False positives",
                       "truePos" = "True positives",
                       "TPR" = "True positive rate",
                       "PPV" = "Positive predictive value",
                       "compositeMeasure" = "Composite measure")
      indexNums <- length(indexes)
    }


    ## Summarizing different measures for extraction performance
    ## separately into list "FinalExtr".
    ## Showing individual values rather than
    ## only showing mean and standard deviation of multiple runs
    {
      FinalExtr <- list()
      toolNames <- character(0)
      for(index in indexes) {
        FinalExtr[[index]] <- data.frame()
      }
      FinalExtr$cosSim <- list()


      ## Combine extraction measures of different datasets:
      for(datasetDir in dataset.dirs){
        thirdLevelDir <- paste0(datasetDir,"/",second.third.level.dirname)
        ## Add multiTools <- NULL to please R check
        multiTools <- NULL
        load(paste0(thirdLevelDir,"/multiTools.RDa"))

        datasetGroupName <- multiTools$datasetGroupName
        datasetSubGroupName <- multiTools$datasetSubGroupName


        ## Find tool names
        toolNames <- unique(multiTools[["averCosSim"]][,"toolName"])

        ## For each extraction measures,
        ## merge values from multiple runs
        ## into one data.frame FinalExtr$<measure_name>
        ## and computational approaches for easier plotting.
        for(index in indexes){
          FinalExtr[[index]] <- rbind(FinalExtr[[index]],multiTools[[index]])
        }

        ## Bind values of cosine similarity in multiTools$cosSim into FinalExtr$cosSim
        gtSigNames <- multiTools$gtSigNames
        if(length(FinalExtr$cosSim) == 0){
          for(gtSigName in gtSigNames) {
            FinalExtr$cosSim[[gtSigName]] <- data.frame()
          }
        }
        for(gtSigName in gtSigNames){
          FinalExtr$cosSim[[gtSigName]] <- rbind(FinalExtr$cosSim[[gtSigName]],multiTools$cosSim[[gtSigName]])
        }
      }

      ## Calculate composite measure for each datasetDir.
      ## It equals to:
      ## True Positive Rate (TPR) + Positive Predictive Value (PPV)
      ## Cosine similarity to each of signature (SBS1 and SBS5 in SBS1-SBS5 paper)
      FinalExtr$compositeMeasure <- FinalExtr$TPR
      FinalExtr$compositeMeasure$value <- FinalExtr$TPR$value + FinalExtr$PPV$value
      for(gtSigName in gtSigNames){
        FinalExtr$compositeMeasure$value <- FinalExtr$compositeMeasure$value + FinalExtr$cosSim[[gtSigName]]$value
      }

    }


    ## Generating csv tables for extraction performance measure
    ## and cosine similarities.
    {
      ## Output combined extraction
      for(index in c(indexes,"compositeMeasure")){

        output <- FinalExtr[[index]]

        output <- output[,-4]
        colnames(output)[1] <- "Seed or run number"
        colnames(output)[2] <- indexLabels[index]
        colnames(output)[3] <- "Name of computational approach"
        colnames(output)[4] <- datasetGroupName
        colnames(output)[5] <- datasetSubGroupName


        write.csv(output,
                  file = paste0(out.dir,"/",index,".csv"))
      }


      for(gtSigName in gtSigNames){

        output <- FinalExtr$cosSim[[gtSigName]]

        output <- output[,-4]
        colnames(output)[1] <- "Seed or run number"
        colnames(output)[2] <- paste0("Cosine similarity to ground-truth signature ",gtSigName)
        colnames(output)[3] <- "Name of computational approach"
        colnames(output)[4] <- datasetGroupName
        colnames(output)[5] <- datasetSubGroupName

        write.csv(output,
                  file = paste0(out.dir,"/cossim.to.",gtSigName,".csv"))
      }
    }


    ## To generate page 3 and page 4 in
    ## extraction summary plots,
    ## values of different measures need to be
    ## merged into one data.frame.
    {
      ## Combine all extraction measurements, FinalExtr[[index]] into FinalExtr$Combined
      ## combined all one-signature cosine similarity, FinalExtr[[gtSigName]] into FinalExtr$Combined
      FinalExtr$combined <- data.frame()
      for(index in c("TPR","PPV")){
        plotDFOneMeasure <- data.frame(FinalExtr[[index]], indexLabel = indexLabels[index])
        FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)
      }

      plotDFOneMeasure <- data.frame(FinalExtr$compositeMeasure, indexLabel = "Composite measure")
      FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)

      for(gtSigName in gtSigNames){
        plotDFOneMeasure <- data.frame(FinalExtr$cosSim[[gtSigName]], indexLabel = paste0("Cosine similarity to ",gtSigName))
        FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)
      }


      ## Convert FinalExtr$combined$datasetGroup and
      ## Let their levels follow gtools::mixedsort() fashion
      ## So that the order of the facet labels will be more reasonable for readers.
      FinalExtr$combined$datasetGroup <- factor(
        FinalExtr$combined$datasetGroup,
        levels = gtools::mixedsort(unique(FinalExtr$combined$datasetGroup)))

      if(!is.null(multiTools$datasetSubGroupName)) {
        FinalExtr$combined$datasetSubGroup <- factor(
          FinalExtr$combined$datasetSubGroup,
          levels = gtools::mixedsort(unique(FinalExtr$combined$datasetSubGroup)))
      }
    }



    ## Plot general pdf for all extraction measures
    ## Plot a general violin + beeswarm plot for multiple measures
    ## in all runs and in all datasets.
    {
      ## Specify the titles of each measure.
      {
        ## Generate separate panels (Composite measure,
        ## Cosine similarity to ground-truth signatures,
        ## True positive rate, Positive predictive value)
        ## and combine them using ggpubr::ggarrage
        plotDFList <- list()
        plotDFList$Extr <- list()
        plotLabels <- character(0)

        ## Composite measure needs to be plotted separately.
        {
          ## data.frame to be plotted in the panel
          plotDFList$compositeMeasure <- FinalExtr$compositeMeasure
          ## Text on Y axis
          plotLabels["compositeMeasure"] <- indexLabels["compositeMeasure"]
        }

        for(measure in c("TPR","PPV")){
          ## data.frame to be plotted in the panel
          plotDFList$Extr[[measure]] <- FinalExtr[[measure]]
          ## Text on Y axis
          plotLabels[measure] <- indexLabels[measure]
        }

        for(gtSigName in gtSigNames){
          ## data.frame to be plotted in the panel
          plotDFList$Extr[[gtSigName]] <- FinalExtr$cosSim[[gtSigName]]

          plotLabels[gtSigName] <- paste0("Cosine similarity to ",gtSigName)
        }
      }


      ## Plot violin plots for extraction summary.
      ##
      ## Page 1: composite measure
      ## Page 2: combination of measures (Cosine similarity to ground-truth signatures, TPR, PPV)
      ## Page 3: extraction measures as a function of correlation
      ## Page 4: extraction measures as a function of signature counts ratio
      {
        plottingFunc <- function(PlotDF,YCaption) {
          ggObj <- ggplot2::ggplot(
            PlotDF,
            ggplot2::aes(x = .data$toolName, y = .data$value)) +
            ## Draw geom_violin and geom_quasirandom
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              #ggplot2::aes(fill = index),
              ## Maximize the violin plot width
              scale = "width",
              ## Make bandwidth larger
              #position = "dodge",
              #width = 1.2
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ## Show median of the extraction measure distribution, as a solid dot.
            ggplot2::stat_summary(fun="median", geom="point", fill = "red", shape = 21) +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", fill="blue", shape = 23) +
            ## Change axis titles
            ggplot2::labs(x = "Approach", y = YCaption) +
            ## Rotate axis.text.x 90 degrees,
            ## move axis.text.x right below the tick marks,
            ## and remove legends.
            ggplot2::theme(
              axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1,vjust = 0.5),
              ## Make font size of facet label smaller.
              strip.text = ggplot2::element_text(size = 10),
              ## remove legends.
              legend.position = "none")
          return(ggObj)
        }

        ggplotsExtr <- list()
        ggplotsExtr$Measures <- list()
        for(gtSigName in gtSigNames){
          ggplotsExtr$Measures[[gtSigName]] <- plottingFunc(plotDFList$Extr[[gtSigName]],paste0("Cosine similarity to ",gtSigName))
        }
        for(measure in c("TPR","PPV")){
          ggplotsExtr$Measures[[measure]] <- plottingFunc(plotDFList$Extr[[measure]],indexLabels[measure])
        }

        ## ggplotObj for PDF 1: Composite measure
        ggplotsExtr$compositeMeasure <- plottingFunc(plotDFList$compositeMeasure,indexLabels["compositeMeasure"])

        ## ggplotObj for PDF 2: combination of measures,
        ## excluding composite measure.
        ggplotsExtr$combinedWOComp <- ggpubr::ggarrange(
          plotlist = ggplotsExtr$Measures,
          font.label = list(size = 14, color = "black", face = "bold", family = "sans"),
          ncol = 2,
          nrow = ceiling(length(plotDFList$Extr)/2),
          legend = "right",
          common.legend = T
        )

        ## Plot a multi-facet ggplot,
        ## facets are separated by measures and datasetGroup
        ## (in example, it refers to slope.)
        if(!is.null(multiTools$datasetSubGroupName)) {
          ## Generate page 3 and page 4
          bys <- c("datasetGroup","datasetSubGroup")
        } else{
          ## Generate page 3 only.
          bys <- c("datasetGroup")
        }

        ## PDF3 with two pages,
        ## combination of all measures,
        ## as a function of datasetGroup or datasetSubGroup
        ggplotsExtr$combined <- list()
        for(by in bys)  {

          ## The value of "datasetGroupName" or "datasetSubGroupName"
          ## which is the caption of "datasetGroup"
          byCaption <- eval(parse(text = paste0("multiTools$",by,"Name")))

          ## Generate a ggplot object based on FinalExtr$combined
          ggplotsExtr$combined[[by]] <- ggplot2::ggplot(
            FinalExtr$combined,
            ggplot2::aes(x = .data$toolName, y = .data$value)) +
            ## Draw geom_violin and geom_quasirandom
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              #ggplot2::aes(fill = index),
              ## Maximize the violin plot width
              scale = "width",
              ## Make bandwidth larger
              #position = "dodge",
              #width = 1.2
              ## Hide outliers
              #outlier.shape = NA
            ) +
            #
            #ggbeeswarm::geom_quasirandom(
            #  groupOnX = TRUE, size = 0.3
            #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
            #) +
            ## Show median of the extraction measure distribution, as a solid dot.
            ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
            ## Change axis titles
            ggplot2::labs(x = "Approach") +
            ## Remove axis.title.y (defaults to be "value", meaningless)
            ## Rotate the axis.text.x (names of tools),
            ## move axis.text.x right below the tick marks
            ## and remove legends
            ggplot2::theme(
              ## Remove axis.title.y
              axis.title.y = ggplot2::element_blank(),
              axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools)
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
              ## remove legends
              legend.position = "none") +
            ## Split the plot into multiple facets,
            ## according to different measures
            ggplot2::facet_grid(
              rows =  ggplot2::vars(.data$indexLabel),
              cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
              scales = "free",
              ## Let facet label to be print on multiple lines
              labeller = ggplot2::label_wrap_gen(multi_line = T)
            ) +
            ## Make facet label font size smaller
            ggplot2::theme(strip.text.y = ggplot2::element_text(size = 4)) +
            ## Add title for general violin + beeswarm plot
            ggplot2::ggtitle(
              label = paste0("Measures of extraction performance as a function of"),
              subtitle = paste0(byCaption,"."))
        }
        ## Plot violin + beeswarm plots in pdf format

        ## PDF 1: Composite measure
        grDevices::pdf(paste0(out.dir,"/compositeMeasure.pdf"),
                       width = 3.5,
                       height = 3.5, ## Make height larger
                       pointsize = 1)
        plot(ggplotsExtr$compositeMeasure)
        grDevices::dev.off()


        ## PDF 2: Cosine similarity to ground-truth, TPR, PPV
        grDevices::pdf(paste0(out.dir,"/combined.measures.wo.composite.pdf"),
                       width = 7,
                       height = 7,
                       pointsize = 1)
        plot(ggplotsExtr$combinedWOComp)
        grDevices::dev.off()


        ## PDF 3 and 4: all measures, against datasetGroupName or datsetSubGroupName
        grDevices::pdf(paste0(out.dir,"/combined.measures.additional.pdf"),
                       width = 7,
                       height = 10.5,
                       pointsize = 1)
        for(by in names(ggplotsExtr$combined)){
          print(ggplotsExtr$combined[[by]])
        }
        grDevices::dev.off()
      }

    }


    ## Plot general png and pdf for one-signature cosine similarity summary
    ## Plot a general violin + beeswarm plot for multiple signatures
    ## in all runs and in all datasets.
    {
      ## For ground-truth signature,
      ## Create a data.frame integrating results of
      ## all runs and for all datasets
      gtSigNames <- multiTools$gtSigNames
      sigNums <- length(gtSigNames)

      ## Combine all FinalExtr$cosSim[[gtSigName]] into FinalExtr$cosSimCombined
      FinalExtr$cosSimCombined <- data.frame()
      for(gtSigName in gtSigNames){
        plotDFOneMeasure <- data.frame(FinalExtr$cosSim[[gtSigName]], gtSigName = gtSigName)
        FinalExtr$cosSimCombined <- rbind(FinalExtr$cosSimCombined,plotDFOneMeasure)
      }
      ## Convert FinalExtr$combined$datasetGroup and
      ## Let their levels follow gtools::mixedsort() fashion
      ## So that the order of the facet labels will be more reasonable for readers.
      FinalExtr$cosSimCombined$datasetGroup <- factor(
        FinalExtr$cosSimCombined$datasetGroup,
        levels = gtools::mixedsort(unique(FinalExtr$cosSimCombined$datasetGroup)))

      if(!is.null(multiTools$datasetSubGroupName)) {
        FinalExtr$cosSimCombined$datasetSubGroup <- factor(
          FinalExtr$cosSimCombined$datasetSubGroup,
          levels = gtools::mixedsort(unique(FinalExtr$cosSimCombined$datasetSubGroup)))
      }

      ## Plot a multi-facet ggplot for all gtSigNames and all runs.
      ggplotList <- list()
      {
        ## Generate a ggplot object based on FinalExtr$combined
        ggplotList$general <- ggplot2::ggplot(
          FinalExtr$cosSimCombined,
          ggplot2::aes(x = .data$toolName, y = .data$value))
        ## Draw geom_violin and geom_quasirandom
        ggplotList$general <- ggplotList$general +
          ggplot2::geom_violin(
            ## Change filling color to white
            fill = "#FFFFFF",
            #ggplot2::aes(fill = gtSigName),
            ##
            scale = "width",
            ## Make bandwidth larger
            #position = "dodge",
            #width = 1.2
            ## Hide outliers
            #outlier.shape = NA
          ) +
          #
          #ggbeeswarm::geom_quasirandom(
          #  groupOnX = TRUE, size = 0.3
          #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
          #) +
          ## Show median of the cosine similarity distribution
          ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
          ## Show mean of the extraction meaasure distribution, as a blue diamond.
          ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
          ## Add title for general violin + beeswarm plot
          ggplot2::ggtitle(label = "Average cosine similarity between ground-truth and extracted signatures",
                           subtitle = "for all computational approaches, ratios and correlation values.") +
          ## Change axis titles
          ggplot2::labs(x = "Computational approach",
                        y = "Cosine Similarity") +
          ## Rotate the axis.text.x (names of tools),
          ## move axis.text.x right below the tick marks
          ## and remove legends
          ggplot2::theme(axis.text.x = ggplot2::element_text(
            ## Rotate the axis.text.x (names of tools)
            angle = 90,
            ## move axis.text.x right below the tick marks
            hjust = 1, vjust = 0.5),
            ## remove legends.
            legend.position = "none") +
          ## Split the plot into multiple facets,
          ## according to different gtSigNames
          ggplot2::facet_wrap(
            ggplot2::vars(gtSigName),
            ## Force facet_wrap to have 2 columns
            ncol = 2,
            scales = "free",
            ## Let facets be plotted vertically
            dir = "v"
          ) +
          ## Restrict the decimal numbers of values of measures to be 2
          ggplot2::scale_y_continuous(
            ## For one-signature cosine similarity, set ylim from the minimum of cosine similarity value to 1
            limits = c(min(FinalExtr$cosSimCombined$value), 1),
            labels =function(x) sprintf("%.2f", x))
      }
      ## Plot a multi-facet ggplot,
      ## facets are separated by gtSigNames and datasetGroup
      ## (in example, it refers to slope.)
      if(!is.null(multiTools$datasetSubGroupName)) {
        bys <- c("datasetGroup","datasetSubGroup")
      } else {
        bys <- c("datasetGroup")
      }

      for(by in bys)  {

        ## The value of "datasetGroupName" or "datasetSubGroupName"
        ## which is the caption of "datasetGroup"
        byCaption <- eval(parse(
          text = paste0("multiTools$",by,"Name")))

        ## Generate a ggplot object based on FinalExtr$combined
        ggplotList[[by]] <- ggplot2::ggplot(
          FinalExtr$cosSimCombined,
          ggplot2::aes(x = .data$toolName, y = .data$value)) +
          ## Draw geom_violin and geom_quasirandom
          ggplot2::geom_violin(
            ## Change filling color to white
            fill = "#FFFFFF",
            #ggplot2::aes(fill = gtSigName),
            ## Maximize the violin plot width
            scale = "width",
            ## Make bandwidth larger
            #position = "dodge",
            #width = 1.2
            ## Hide outliers
            #outlier.shape = NA
          ) +
          #ggbeeswarm::geom_quasirandom(
          #  groupOnX = TRUE, size = 0.3
          #  ## Need to add a single color (different from black)
          #  ## for all data points.
          #  , ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
          #) +
          ## Show median of the extraction measure distribution
          ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
          ## Show mean of the extraction meaasure distribution, as a blue diamond.
          ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
          ## Add title for general violin + beeswarm plot
          ggplot2::ggtitle(
            label = paste0("Extraction cosine similarity as a function of"),
            subtitle = paste0(byCaption,".")) +
          ## Change axis titles
          ggplot2::labs(x = "Computational approach",
                        y = "Cosine Similarity") +
          ## Rotate the axis.text.x (names of tools),
          ## move axis.text.x right below the tick marks
          ## and remove legends
          ggplot2::theme(axis.text.x = ggplot2::element_text(
            ## Rotate the axis.text.x (names of tools)
            angle = 90,
            ## move axis.text.x right below the tick marks
            hjust = 1, vjust = 0.5),
            ## remove legends.
            legend.position = "none") +
          ## Split the plot into multiple facets,
          ## according to different gtSigNames
          ggplot2::facet_grid(rows = ggplot2::vars(gtSigName),
                              cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
                              scales = "free") +
          ## Restrict the decimal numbers of values of measures to be 2
          ggplot2::scale_y_continuous(
            ## For one-signature cosine similarity, set ylim from the minimum of cosine similarity value to 1
            limits = c(min(FinalExtr$cosSimCombined$value), 1),
            labels = function(x) sprintf("%.2f", x))
      }

      ## Plot violin + beeswarm plots in pdf format
      grDevices::pdf(paste0(out.dir,"/onesig.cossim.violins.pdf"), pointsize = 1)
      for(by in names(ggplotList)){
        print(ggplotList[[by]])
      }
      grDevices::dev.off()
    }

    ## Summarize aggregated scaled Manhattan distance only if
    ## multiTools$AggManhattanDist exists.
    {
      flagExposure <- TRUE
      ## Combine attribution assessment onto multiple sheets.
      ## Each sheet shows Scaled Manhattan distance for one mutational signature.
      for(datasetDir in dataset.dirs){
        thirdLevelDir <- paste0(datasetDir,"/",second.third.level.dirname)
        ## Add multiTools <- NULL to please R check
        multiTools <- NULL
        load(paste0(thirdLevelDir,"/multiTools.RDa"))
        if(is.null(multiTools$AggManhattanDist)){
          flagExposure <- FALSE
          message("Skip summarizing scaled Manhattan distance...\n")
          break
        }
      }
    }

    ## Summarizing aggregated Scaled Manhattan distance results
    if(flagExposure){
      {
        FinalAttr <- list()
        FinalAttr$AggManhattanDist <- list()
        ## Combine attribution assessment onto multiple sheets.
        ## Each sheet shows Scaled Manhattan distance for one mutational signature.
        for(datasetDir in dataset.dirs){
          thirdLevelDir <- paste0(datasetDir,"/",second.third.level.dirname)
          ## Add multiTools <- NULL to please R check
          multiTools <- NULL
          load(paste0(thirdLevelDir,"/multiTools.RDa"))

          gtSigNames <- multiTools$gtSigNames
          sigNums <- length(gtSigNames)

          if(length(FinalAttr$AggManhattanDist) == 0){
            for(gtSigName in gtSigNames) {
              FinalAttr$AggManhattanDist[[gtSigName]] <- data.frame()
            }
          }

          ## Combine Scaled Manhattan distance
          for(gtSigName in gtSigNames){
            FinalAttr$AggManhattanDist[[gtSigName]] <- rbind(
              FinalAttr$AggManhattanDist[[gtSigName]],
              multiTools$AggManhattanDist[[gtSigName]])
          }
        }

        ## For the purpose of SBS1-SBS5 paper,
        ## don't output summary tables for aggregated scaled Manhattan distance.
        if(FALSE){
          for(gtSigName in gtSigNames){
            output <- FinalAttr$AggManhattanDist[[gtSigName]]

            output <- output[,-4]
            colnames(output)[1] <- "Seed or run number"
            colnames(output)[2] <- paste0("Scaled distance of ",gtSigName)
            colnames(output)[3] <- "Name of computational approach"
            colnames(output)[4] <- datasetGroupName
            colnames(output)[5] <- datasetSubGroupName

            write.csv(output,
                      file = paste0(out.dir,"/Agg.ManhattanDist.",gtSigName,".csv"))
          }
        }

        ## Plot general png and pdf for attribution Scaled Manhattan distance summary
        ## Plot a general violin + beeswarm plot for multiple signatures
        ## in all runs and in all datasets.
        {

          ## Combine all FinalAttr$AggManhattanDist[[gtSigName]] into FinalAttr$AggManhattanDist$Combined
          FinalAttr$AggManhattanDist$combined <- data.frame()
          for(gtSigName in gtSigNames){
            plotDFOneMeasure <- data.frame(FinalAttr$AggManhattanDist[[gtSigName]], gtSigName = gtSigName)
            FinalAttr$AggManhattanDist$combined <- rbind(FinalAttr$AggManhattanDist$combined,plotDFOneMeasure)
          }

          ## Convert FinalAttr$AggManhattanDist$combined$datasetGroup and
          ## Let their levels follow gtools::mixedsort() fashion
          ## So that the order of the facet labels will be more reasonable for readers.
          FinalAttr$AggManhattanDist$combined$datasetGroup <- factor(
            FinalAttr$AggManhattanDist$combined$datasetGroup,
            levels = gtools::mixedsort(unique(FinalAttr$AggManhattanDist$combined$datasetGroup)))

          if(!is.null(multiTools$datasetSubGroupName)) {
            FinalAttr$AggManhattanDist$combined$datasetSubGroup <- factor(
              FinalAttr$AggManhattanDist$combined$datasetSubGroup,
              levels = gtools::mixedsort(unique(FinalAttr$AggManhattanDist$combined$datasetSubGroup)))
          }

          ggplotList <- list()
          ## Plot a multi-facet ggplot for all gtSigNames and all runs.
          {
            ## Generate a ggplot object based on FinalAttr$AggManhattanDist$combined
            ggplotList$general <- ggplot2::ggplot(
              FinalAttr$AggManhattanDist$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value)) +
              ## Draw geom_violin and geom_quasirandom
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width",
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              #ggbeeswarm::geom_quasirandom(
              #  groupOnX = TRUE, size = 0.3
              #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
              #) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin + beeswarm plot
              ggplot2::ggtitle(label = "Scaled aggregated Manhattan distance between inferred and ground-truth",
                               subtitle = "exposures for all computational approaches, ratios and correlation values.") +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = "Scaled aggregated Manhattan distance") +
              ## Rotate the names of tools,
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_wrap(
                ggplot2::vars(gtSigName),
                ## Force facet_wrap to have 2 columns
                ncol = 2,
                scales = "free",
                ## Let facets be plotted vertically
                dir = "v"
              ) +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr$AggManhattanDist$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }
          ## Plot a multi-facet ggplot,
          ## facets are separated by gtSigNames and datasetGroup
          ## (in example, it refers to slope.)
          if(!is.null(multiTools$datasetSubGroupName)) {
            bys <- c("datasetGroup","datasetSubGroup")
          } else {
            bys <- c("datasetGroup")
          }

          for(by in bys)  {

            ## The value of "datasetGroupName" or "datasetSubGroupName"
            ## which is the caption of "datasetGroup"
            byCaption <- eval(parse(
              text = paste0("multiTools$",by,"Name")))


            ## Generate a ggplot object based on FinalAttr$AggManhattanDist$combined
            ggplotList[[by]] <- ggplot2::ggplot(
              FinalAttr$AggManhattanDist$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value))
            ## Draw geom_violin and geom_quasirandom
            ggplotList[[by]] <- ggplotList[[by]] +
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width"
                #,
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              #ggbeeswarm::geom_quasirandom(
              #  groupOnX = TRUE, size = 0.3
              #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
              #) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin + beeswarm plot
              ggplot2::ggtitle(
                label = paste0("Scaled aggregated Manhattan distance summary plot as a function of "),
                subtitle = paste0("ground-truth signature names and ",byCaption,".")) +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = "Scaled aggregated Manhattan distance") +
              ## Rotate the axis.text.x (names of tools),
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_grid(rows =  ggplot2::vars(gtSigName),
                                  cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
                                  scales = "free") +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr$AggManhattanDist$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }

          ## Plot violin + beeswarm plots in pdf format
          grDevices::pdf(paste0(out.dir,"/Aggregated.Scaled.Manhattan.Dist.violins.pdf"), pointsize = 1)
          for(by in names(ggplotList)){
            print(ggplotList[[by]])
          }
          grDevices::dev.off()
        }
      }


    }

    ## Summarizing results for mean and stdev of separated Manhattan distance
    if(flagExposure){

      fileNames = c(
        "meanSepMD" = "mean.of.sep.Scaled.Manhattan.dist",
        "sdSepMD" = "stdev.of.sep.Scaled.Manhattan.dist")
      titles = c(
        "meanSepMD" = "Mean of Manhattan distances of individual tumors",
        "sdSepMD" = "Standard deviation of Manhattan distances of individual tumors"
      )

      for(measure in c("meanSepMD", "sdSepMD"))
      {
        FinalAttr[[measure]] <- list()
        ## Combine attribution assessment onto multiple sheets.
        ## Each sheet shows Scaled Manhattan distance for one mutational signature.
        for(datasetDir in dataset.dirs){
          thirdLevelDir <- paste0(datasetDir,"/",second.third.level.dirname)
          ## Add multiTools <- NULL to please R check
          multiTools <- NULL
          load(paste0(thirdLevelDir,"/multiTools.RDa"))

          gtSigNames <- multiTools$gtSigNames
          sigNums <- length(gtSigNames)

          if(length(FinalAttr[[measure]]) == 0){
            for(gtSigName in gtSigNames) {
              FinalAttr[[measure]][[gtSigName]] <- data.frame()
            }
          }

          ## Combine Scaled Manhattan distance
          for(gtSigName in gtSigNames){
            FinalAttr[[measure]][[gtSigName]] <- rbind(
              FinalAttr[[measure]][[gtSigName]],
              multiTools[[measure]][[gtSigName]])
          }
        }

        ## For the purpose of SBS1-SBS5 paper,
        ## don't output summary tables for scaled Manhattan distance.
        if(FALSE){
          for(gtSigName in gtSigNames){
            output <- FinalAttr[[measure]][[gtSigName]]

            output <- output[,-4]
            colnames(output)[1] <- "Seed or run number"
            colnames(output)[2] <- paste0("Scaled distance of ",gtSigName)
            colnames(output)[3] <- "Name of computational approach"
            colnames(output)[4] <- datasetGroupName
            colnames(output)[5] <- datasetSubGroupName

            write.csv(output,
                      file = paste0(out.dir,"/",fileNames[measure],".",gtSigName,".csv"))
          }
        }

        ## Plot general png and pdf for attribution Scaled Manhattan distance summary
        ## Plot a general violin + beeswarm plot for multiple signatures
        ## in all runs and in all datasets.
        {

          ## Combine all FinalAttr[[measure]][[gtSigName]] into FinalAttr[[measure]]$Combined
          FinalAttr[[measure]]$combined <- data.frame()
          for(gtSigName in gtSigNames){
            plotDFOneMeasure <- data.frame(FinalAttr[[measure]][[gtSigName]], gtSigName = gtSigName)
            FinalAttr[[measure]]$combined <- rbind(FinalAttr[[measure]]$combined,plotDFOneMeasure)
          }

          ## Convert FinalAttr[[measure]]$combined$datasetGroup and
          ## Let their levels follow gtools::mixedsort() fashion
          ## So that the order of the facet labels will be more reasonable for readers.
          FinalAttr[[measure]]$combined$datasetGroup <- factor(
            FinalAttr[[measure]]$combined$datasetGroup,
            levels = gtools::mixedsort(unique(FinalAttr[[measure]]$combined$datasetGroup)))

          if(!is.null(multiTools$datasetSubGroupName)) {
            FinalAttr[[measure]]$combined$datasetSubGroup <- factor(
              FinalAttr[[measure]]$combined$datasetSubGroup,
              levels = gtools::mixedsort(unique(FinalAttr[[measure]]$combined$datasetSubGroup)))
          }

          ggplotList <- list()
          ## Plot a multi-facet ggplot for all gtSigNames and all runs.
          {
            ## Generate a ggplot object based on FinalAttr[[measure]]$combined
            ggplotList$general <- ggplot2::ggplot(
              FinalAttr[[measure]]$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value)) +
              ## Draw geom_violin and geom_quasirandom
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width",
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              #ggbeeswarm::geom_quasirandom(
              #  groupOnX = TRUE, size = 0.3
              #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
              #) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin + beeswarm plot
              ggplot2::ggtitle(label = titles[measure],
                               subtitle = " between inferred and ground-truth exposures.") +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = titles[measure]) +
              ## Rotate the names of tools,
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_wrap(
                ggplot2::vars(gtSigName),
                ## Force facet_wrap to have 2 columns
                ncol = 2,
                scales = "free",
                ## Let facets be plotted vertically
                dir = "v"
              ) +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr[[measure]]$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }
          ## Plot a multi-facet ggplot,
          ## facets are separated by gtSigNames and datasetGroup
          ## (in example, it refers to slope.)
          if(!is.null(multiTools$datasetSubGroupName)) {
            bys <- c("datasetGroup","datasetSubGroup")
          } else {
            bys <- c("datasetGroup")
          }

          for(by in bys)  {

            ## The value of "datasetGroupName" or "datasetSubGroupName"
            ## which is the caption of "datasetGroup"
            byCaption <- eval(parse(
              text = paste0("multiTools$",by,"Name")))


            ## Generate a ggplot object based on FinalAttr[[measure]]$combined
            ggplotList[[by]] <- ggplot2::ggplot(
              FinalAttr[[measure]]$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value))
            ## Draw geom_violin and geom_quasirandom
            ggplotList[[by]] <- ggplotList[[by]] +
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width"
                #,
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              #ggbeeswarm::geom_quasirandom(
              #  groupOnX = TRUE, size = 0.3
              #  ,ggplot2::aes(color = grDevices::hcl(h = 300,c = 35,l = 60)) ## A purple color, albeit deeper than default hcl colors.
              #) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin + beeswarm plot
              ggplot2::ggtitle(
                label = paste0(titles[measure]," as a function of "),
                subtitle = paste0("ground-truth signature names and ",byCaption,".")) +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = titles[measure]) +
              ## Rotate the axis.text.x (names of tools),
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_grid(rows =  ggplot2::vars(gtSigName),
                                  cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
                                  scales = "free") +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr[[measure]]$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }

          ## Plot violin + beeswarm plots in pdf format
          grDevices::pdf(paste0(out.dir,"/",fileNames[measure],".pdf"), pointsize = 1)
          for(by in names(ggplotList)){
            print(ggplotList[[by]])
          }
          grDevices::dev.off()
        }
      }

    }




    FinalSummary <- list()
    FinalSummary$FinalExtr <- FinalExtr
    if(flagExposure) {
      FinalSummary$FinalAttr <- FinalAttr
    }

    save(FinalSummary,file = paste0(out.dir,"/FinalSummary.RDa"))

    invisible(FinalSummary)
  }

