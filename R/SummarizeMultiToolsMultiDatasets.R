#' Summarize results for multiple datasets, by different computational approaches.
#'
#' Summarize results of mutational signature extraction and exposure inference
#' by multiple computational approaches on multiple datasets. Before running this
#' function, make sure the summary file for each single data set
#'  \code{toolSummaryPaths}/\code{OneToolSummary.Rda} exists.
#'
#' \code{OneToolSummary.Rda} is generated by \code{\link{SummarizeOneToolMultiDatasets}}).
#'
#' @param toolSummaryPaths Paths of top-level dataset directories trees you want
#' to investigate.
#' E.g. "./S.0.1.Rsq.0.1"
#'
#' Note: \code{OneToolSummary.RDa} are expected to be exist under
#' \code{toolSummaryPaths}.
#'
#' @param out.dir Path of the output directory.
#'
#' @param display.datasetName Whether to put the name of spectra datasets inside of
#' the csv outputs of summary tables.
#'
#' @param sort.by.composite.extraction.measure Whether to re-order the computational
#' approaches on violin plots, based on the mean of composite measure.
#'
#' \code{"descending"}: Put the computational approach with the highest mean composite
#' measure to the left, and arrange approaches in descending order.
#' \code{"ascending"}:  Put the computational approach with the lowest mean composite
#' measure to the left, and arrange approaches in ascending order.
#' Anything else: Keep the computational approaches in a smart alphabetical order embedded with numbers,
#' defined by \code{\link[gtools](mixedsort)}.
#'
#' @param overwrite Whether to overwrite the contents in out.dir if
#' it already exists. (Default: FALSE)
#'
#' @importFrom rlang .data
#'
#' @importFrom utils write.csv
#'
#' @export
#'
SummarizeMultiToolsMultiDatasets <-
  function(toolSummaryPaths,
           out.dir,
           display.datasetName = FALSE,
           sort.by.composite.extraction.measure = "descending",
           overwrite = FALSE){

    ## Create output directory
    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir, recursive = T)
    }

    ## For each measure,
    ## Create a data.frame integrating results of
    ## all runs and for all datasets
    {
      indexes <- c("averCosSim","falseNeg","falsePos",
                   "truePos","TPR","PPV")
      indexLabels <- c("averCosSim" = "Average cosine similarity of all signatures",
                       "falseNeg" = "False negatives",
                       "falsePos" = "False positives",
                       "truePos" = "True positives",
                       "TPR" = "True positive rate",
                       "PPV" = "Positive predictive value",
                       "compositeMeasure" = "Composite measure")
      indexNums <- length(indexes)
    }


    ## Combining measures for extraction performance
    ## into list "FinalExtr".
    ## Showing individual values rather than
    ## only showing mean and standard deviation of multiple runs
    {
      FinalExtr <- list()
      toolNames <- character(0)
      for(index in indexes) {
        FinalExtr[[index]] <- data.frame()
      }
      FinalExtr$cosSim <- list()
      FinalExtr$NumSigsSimilar <- list()


      ## Combine extraction measures of different computational approaches:
      toolNames <- character(0)
      for(toolSummaryPath in toolSummaryPaths){
        ## Add OneToolSummary <- NULL to please R check
        OneToolSummary <- NULL
        load(paste0(toolSummaryPath,"/OneToolSummary.RDa"))

        datasetGroupName <- OneToolSummary$datasetGroupName
        datasetSubGroupName <- OneToolSummary$datasetSubGroupName


        ## Find tool names
        toolName <- unique(OneToolSummary[["averCosSim"]][,"toolName"])
        toolNames <- c(toolNames, toolName)

        ## For each extraction measures,
        ## merge values from multiple runs
        ## into one data.frame FinalExtr$<measure_name>
        ## and computational approaches for easier plotting.
        for(index in indexes){
          FinalExtr[[index]] <- rbind(FinalExtr[[index]],OneToolSummary[[index]])
        }

        ## Bind values of cosine similarity in OneToolSummary$cosSim into FinalExtr$cosSim
        gtSigNames <- gtools::mixedsort(setdiff(names(OneToolSummary$cosSim),"combined"))

        for(measure in c("cosSim","NumSigsSimilar")){

          if(length(FinalExtr[[measure]]) == 0){
            for(gtSigName in gtSigNames) {
              FinalExtr[[measure]][[gtSigName]] <- data.frame()
            }
          }
          for(gtSigName in gtSigNames){
            FinalExtr[[measure]][[gtSigName]] <-
              rbind(FinalExtr[[measure]][[gtSigName]],
                    OneToolSummary[[measure]][[gtSigName]])
          }

        }

      }

      ## Calculate composite measure for each computational approach.
      ## It equals to:
      ## True Positive Rate (TPR) + Positive Predictive Value (PPV)
      ## Cosine similarity to each of signature (SBS1 and SBS5 in SBS1-SBS5 paper)
      FinalExtr$compositeMeasure <- FinalExtr$TPR
      FinalExtr$compositeMeasure$value <- FinalExtr$TPR$value + FinalExtr$PPV$value
      for(gtSigName in gtSigNames){
        FinalExtr$compositeMeasure$value <- FinalExtr$compositeMeasure$value + FinalExtr$cosSim[[gtSigName]]$value
      }

      ## Order computational approaches according to their mean of composite measure
      if(sort.by.composite.extraction.measure %in% c("ascending","descending")){

        meanCOMPOSITE <- numeric(0)
        for(tool in toolNames){
          rowNums <- which(FinalExtr$compositeMeasure$toolName == tool)
          meanVal <- mean(FinalExtr$compositeMeasure$value[rowNums])
          names(meanVal) <- tool
          meanCOMPOSITE <- c(meanCOMPOSITE, meanVal)
        }
        if(sort.by.composite.extraction.measure == "descending") {
          meanCOMPOSITE <- gtools::mixedsort(meanCOMPOSITE,decreasing = T)
        } else {
          meanCOMPOSITE <- gtools::mixedsort(meanCOMPOSITE,decreasing = F)
        }
        ## Update order of toolNames.
        toolNames <- names(meanCOMPOSITE)
      }

    }


    ## Generating csv tables for extraction performance measure
    ## and cosine similarities.
    {
      ## Output combined extraction
      for(index in c(indexes,"compositeMeasure")){

        output <- FinalExtr[[index]]

        colnames(output)[1] <- "Seed or run number"
        colnames(output)[2] <- indexLabels[index]
        colnames(output)[3] <- "Name of computational approach"
        colnames(output)[4] <- "Name of mutational spectra dataset"
        colnames(output)[5] <- datasetGroupName
        colnames(output)[6] <- datasetSubGroupName

        if(!display.datasetName){
          ## Delete the 4th column,
          ## which refers to the name of the corresponding
          ## spectra dataset.
          output <- output[,-4]
        }

        write.csv(output,
                  file = paste0(out.dir,"/",index,".csv"))
      }


      for(gtSigName in gtSigNames){

        output <- FinalExtr$cosSim[[gtSigName]]

        colnames(output)[1] <- "Seed or run number"
        colnames(output)[2] <- paste0("Cosine similarity to ground-truth signature ",gtSigName)
        colnames(output)[3] <- "Name of computational approach"
        colnames(output)[4] <- "Name of mutational spectra dataset"
        colnames(output)[5] <- datasetGroupName
        colnames(output)[6] <- datasetSubGroupName

        if(!display.datasetName){
          ## Delete the 4th column,
          ## which refers to the name of the corresponding
          ## spectra dataset.
          output <- output[,-4]
        }

        write.csv(output,
                  file = paste0(out.dir,"/cossim.to.",gtSigName,".csv"))
      }

      for(gtSigName in gtSigNames){

        output <- FinalExtr$NumSigsSimilar[[gtSigName]]

        colnames(output)[1] <- "Seed or run number"
        colnames(output)[2] <- paste0("Number of software-reported signatures with ",
                                      "cosine similarity > 0.9 to ",gtSigName)
        colnames(output)[3] <- "Name of computational approach"
        colnames(output)[4] <- "Name of mutational spectra dataset"
        colnames(output)[5] <- datasetGroupName
        colnames(output)[6] <- datasetSubGroupName

        if(!display.datasetName){
          ## Delete the 4th column,
          ## which refers to the name of the corresponding
          ## spectra dataset.
          output <- output[,-4]
        }

        write.csv(output,
                  file = paste0(out.dir,"/num.sigs.similar.to.",
                                gtSigName,".csv"))
      }


    }


    ## To generate page 3 and page 4 in
    ## extraction summary plots,
    ## values of different measures need to be
    ## merged into one data.frame.
    {
      ## Combine all extraction measurements, FinalExtr[[index]] into FinalExtr$Combined
      ## combined all one-signature cosine similarity, FinalExtr[[gtSigName]] into FinalExtr$Combined
      FinalExtr$combined <- data.frame()
      for(index in c("TPR","PPV")){
        plotDFOneMeasure <- data.frame(
          FinalExtr[[index]], indexLabel = indexLabels[index],
          row.names = NULL)
        rownames(plotDFOneMeasure) <- NULL
        FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)
      }

      plotDFOneMeasure <- data.frame(
        FinalExtr$compositeMeasure, indexLabel = "Composite measure",
        row.names = NULL)
      rownames(plotDFOneMeasure) <- NULL
      FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)

      for(gtSigName in gtSigNames){
        plotDFOneMeasure <- data.frame(
          FinalExtr$cosSim[[gtSigName]], indexLabel = paste0("Cosine similarity to ",gtSigName),
          row.names = NULL)
        rownames(plotDFOneMeasure) <- NULL
        FinalExtr$combined <- rbind(FinalExtr$combined,plotDFOneMeasure)
      }


      ## Convert FinalExtr$combined$datasetGroup and
      ## Let their levels follow gtools::mixedsort() fashion
      ## So that the order of the facet labels will be more reasonable for readers.
      FinalExtr$combined$datasetGroup <- factor(
        FinalExtr$combined$datasetGroup,
        levels = gtools::mixedsort(unique(FinalExtr$combined$datasetGroup)))

      if(!is.null(OneToolSummary$datasetSubGroupName)) {
        FinalExtr$combined$datasetSubGroup <- factor(
          FinalExtr$combined$datasetSubGroup,
          levels = gtools::mixedsort(unique(FinalExtr$combined$datasetSubGroup)))
      }
    }



    ## Plot general pdf for all extraction measures
    ## Plot a general violin plot for multiple measures
    ## in all runs and in all datasets.
    {
      ## Specify the titles of each measure.
      {
        ## Generate separate panels (Composite measure,
        ## Cosine similarity to ground-truth signatures,
        ## True positive rate, Positive predictive value)
        ## and combine them using ggpubr::ggarrange
        plotDFList <- list()
        plotDFList$Extr <- list()
        plotLabels <- character(0)

        ## Composite measure needs to be plotted separately.
        {
          ## data.frame to be plotted in the panel
          plotDFList$compositeMeasure <- FinalExtr$compositeMeasure
          ## Text on Y axis
          plotLabels["compositeMeasure"] <- indexLabels["compositeMeasure"]
        }

        for(measure in c("TPR","PPV")){
          ## data.frame to be plotted in the panel
          plotDFList$Extr[[measure]] <- FinalExtr[[measure]]
          ## Text on Y axis
          plotLabels[measure] <- indexLabels[measure]
        }

        for(gtSigName in gtSigNames){
          ## data.frame to be plotted in the panel
          plotDFList$Extr[[gtSigName]] <- FinalExtr$cosSim[[gtSigName]]

          plotLabels[gtSigName] <- paste0("Cosine similarity to ",gtSigName)
        }
      }


      ## Plot violin plots for extraction summary.
      ##
      ## Page 1: composite measure
      ## Page 2: combination of measures (Cosine similarity to ground-truth signatures, TPR, PPV)
      ## Page 3: extraction measures as a function of correlation
      ## Page 4: extraction measures as a function of signature counts ratio
      {
        plottingFunc <- function(PlotDF,YCaption) {
          ggObj <- ggplot2::ggplot(
            PlotDF,
            ggplot2::aes(x = .data$toolName, y = .data$value)) +
            ## Draw geom_violin and geom_quasirandom
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              #ggplot2::aes(fill = index),
              ## Maximize the violin plot width
              scale = "width",
              ## Make bandwidth larger
              #position = "dodge",
              #width = 1.2
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ## Set the order of computational approaches to the
            ## reordered-vector toolNames
            ggplot2::scale_x_discrete(limits = toolNames) +
            ## Show median of the extraction measure distribution, as a solid dot.
            ggplot2::stat_summary(fun="median", geom="point", fill = "red", shape = 21) +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", fill="blue", shape = 23) +
            ## Change axis titles
            ggplot2::labs(x = "Approach", y = YCaption) +
            ## Rotate axis.text.x 90 degrees,
            ## move axis.text.x right below the tick marks,
            ## and remove legends.
            ggplot2::theme(
              axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1,vjust = 0.5),
              ## Make font size of facet label smaller.
              strip.text = ggplot2::element_text(size = 10),
              ## remove legends.
              legend.position = "none")
          return(ggObj)
        }

        ggplotsExtr <- list()
        ggplotsExtr$Measures <- list()
        for(gtSigName in gtSigNames){
          ggplotsExtr$Measures[[gtSigName]] <- plottingFunc(plotDFList$Extr[[gtSigName]],paste0("Cosine similarity to ",gtSigName))
        }
        for(measure in c("TPR","PPV")){
          ggplotsExtr$Measures[[measure]] <- plottingFunc(plotDFList$Extr[[measure]],indexLabels[measure])
        }

        ## ggplotObj for PDF 1: Composite measure
        ggplotsExtr$compositeMeasure <- plottingFunc(plotDFList$compositeMeasure,indexLabels["compositeMeasure"])

        ## ggplotObj for PDF 2: combination of measures,
        ## excluding composite measure.
        ggplotsExtr$combinedWOComp <- ggpubr::ggarrange(
          plotlist = ggplotsExtr$Measures,
          font.label = list(size = 14, color = "black", face = "bold", family = "sans"),
          ncol = 2,
          nrow = ceiling(length(plotDFList$Extr)/2),
          legend = "right",
          common.legend = T
        )

        ## Plot a multi-facet ggplot,
        ## facets are separated by measures and datasetGroup
        ## (in example, it refers to slope.)
        if(!is.null(OneToolSummary$datasetSubGroupName)) {
          ## Generate page 3 and page 4
          bys <- c("datasetGroup","datasetSubGroup")
        } else{
          ## Generate page 3 only.
          bys <- c("datasetGroup")
        }

        ## PDF3 with two pages,
        ## combination of all measures,
        ## as a function of datasetGroup or datasetSubGroup
        ggplotsExtr$combined <- list()
        for(by in bys)  {

          ## The value of "datasetGroupName" or "datasetSubGroupName"
          ## which is the caption of "datasetGroup"
          byCaption <- eval(parse(text = paste0("OneToolSummary$",by,"Name")))

          ## Generate a ggplot object based on FinalExtr$combined
          ggplotsExtr$combined[[by]] <- ggplot2::ggplot(
            FinalExtr$combined,
            ggplot2::aes(x = .data$toolName, y = .data$value)) +
            ## Draw geom_violin and geom_quasirandom
            ggplot2::geom_violin(
              ## Change filling color to white
              fill = "#FFFFFF",
              #ggplot2::aes(fill = index),
              ## Maximize the violin plot width
              scale = "width",
              ## Make bandwidth larger
              #position = "dodge",
              #width = 1.2
              ## Hide outliers
              #outlier.shape = NA
            ) +
            ## Let the names of computational approaches
            ## follow the order in toolNames.
            ggplot2::scale_x_discrete(limits = toolNames) +
            ## Show median of the extraction measure distribution, as a solid dot.
            ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
            ## Show mean of the extraction meaasure distribution, as a blue diamond.
            ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
            ## Change axis titles
            ggplot2::labs(x = "Approach") +
            ## Remove axis.title.y (defaults to be "value", meaningless)
            ## Rotate the axis.text.x (names of tools),
            ## move axis.text.x right below the tick marks
            ## and remove legends
            ggplot2::theme(
              ## Remove axis.title.y
              axis.title.y = ggplot2::element_blank(),
              axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools)
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
              ## remove legends
              legend.position = "none") +
            ## Split the plot into multiple facets,
            ## according to different measures
            ggplot2::facet_grid(
              rows =  ggplot2::vars(.data$indexLabel),
              cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
              scales = "free",
              ## Let facet label to be print on multiple lines
              labeller = ggplot2::label_wrap_gen(multi_line = T)
            ) +
            ## Make facet label font size smaller
            ggplot2::theme(strip.text.y = ggplot2::element_text(size = 4)) +
            ## Add title for general violin plot
            ggplot2::ggtitle(
              label = paste0("Measures of extraction performance as a function of"),
              subtitle = paste0(byCaption,"."))
        }
        ## Plot violin plots in pdf format

        ## PDF 1: Composite measure
        grDevices::pdf(paste0(out.dir,"/compositeMeasure.pdf"),
                       width = 3.5,
                       height = 3.5, ## Make height larger
                       pointsize = 1)
        plot(ggplotsExtr$compositeMeasure)
        grDevices::dev.off()


        ## PDF 2: Cosine similarity to ground-truth, TPR, PPV
        grDevices::pdf(paste0(out.dir,"/combined.measures.wo.composite.pdf"),
                       width = 7,
                       height = 7,
                       pointsize = 1)
        plot(ggplotsExtr$combinedWOComp)
        grDevices::dev.off()


        ## PDF 3 and 4: all measures, against datasetGroupName or datsetSubGroupName
        grDevices::pdf(paste0(out.dir,"/combined.measures.additional.pdf"),
                       width = 7,
                       height = 10.5,
                       pointsize = 1)
        for(by in names(ggplotsExtr$combined)){
          print(ggplotsExtr$combined[[by]])
        }
        grDevices::dev.off()
      }

    }


    ## Summarize aggregated scaled Manhattan distance only if
    ## OneToolSummary$AggManhattanDist exists.
    {
      flagExposure <- TRUE
      ## Combine attribution assessment onto multiple sheets.
      ## Each sheet shows Scaled Manhattan distance for one mutational signature.
      for(toolSummaryPath in toolSummaryPaths){
        ## Add OneToolSummary <- NULL to please R check
        OneToolSummary <- NULL
        load(paste0(toolSummaryPath,"/OneToolSummary.RDa"))
        if(is.null(OneToolSummary$AggManhattanDist)){
          flagExposure <- FALSE
          message("Skip summarizing scaled Manhattan distance...\n")
          break
        }
      }
    }

    ## Summarizing aggregated Scaled Manhattan distance results
    if(flagExposure){
      {
        FinalAttr <- list()
        FinalAttr$AggManhattanDist <- list()
        ## Combine attribution assessment onto multiple sheets.
        ## Each sheet shows Scaled Manhattan distance for one mutational signature.
        for(toolSummaryPath in toolSummaryPaths){
          ## Add OneToolSummary <- NULL to please R check
          OneToolSummary <- NULL
          load(paste0(toolSummaryPath,"/OneToolSummary.RDa"))

          if(length(FinalAttr$AggManhattanDist) == 0){
            for(gtSigName in gtSigNames) {
              FinalAttr$AggManhattanDist[[gtSigName]] <- data.frame()
            }
          }

          ## Combine Scaled Manhattan distance
          for(gtSigName in gtSigNames){
            FinalAttr$AggManhattanDist[[gtSigName]] <- rbind(
              FinalAttr$AggManhattanDist[[gtSigName]],
              OneToolSummary$AggManhattanDist[[gtSigName]])
          }
        }

        ## For the purpose of SBS1-SBS5 paper,
        ## don't output summary tables for aggregated scaled Manhattan distance.
        if(FALSE){
          for(gtSigName in gtSigNames){
            output <- FinalAttr$AggManhattanDist[[gtSigName]]

            colnames(output)[1] <- "Seed or run number"
            colnames(output)[2] <- paste0("Scaled distance of ",gtSigName)
            colnames(output)[3] <- "Name of computational approach"
            colnames(output)[4] <- datasetGroupName
            colnames(output)[5] <- datasetSubGroupName

            write.csv(output,
                      file = paste0(out.dir,"/Agg.ManhattanDist.",gtSigName,".csv"))
          }
        }

        ## Plot general png and pdf for attribution Scaled Manhattan distance summary
        ## Plot a general violin plot for multiple signatures
        ## in all runs and in all datasets.
        {

          ## Combine all FinalAttr$AggManhattanDist[[gtSigName]] into FinalAttr$AggManhattanDist$Combined
          FinalAttr$AggManhattanDist$combined <- data.frame()
          for(gtSigName in gtSigNames){
            plotDFOneMeasure <- data.frame(FinalAttr$AggManhattanDist[[gtSigName]], gtSigName = gtSigName)
            FinalAttr$AggManhattanDist$combined <- rbind(FinalAttr$AggManhattanDist$combined,plotDFOneMeasure)
          }

          ## Convert FinalAttr$AggManhattanDist$combined$datasetGroup and
          ## Let their levels follow gtools::mixedsort() fashion
          ## So that the order of the facet labels will be more reasonable for readers.
          FinalAttr$AggManhattanDist$combined$datasetGroup <- factor(
            FinalAttr$AggManhattanDist$combined$datasetGroup,
            levels = gtools::mixedsort(unique(FinalAttr$AggManhattanDist$combined$datasetGroup)))

          if(!is.null(OneToolSummary$datasetSubGroupName)) {
            FinalAttr$AggManhattanDist$combined$datasetSubGroup <- factor(
              FinalAttr$AggManhattanDist$combined$datasetSubGroup,
              levels = gtools::mixedsort(unique(FinalAttr$AggManhattanDist$combined$datasetSubGroup)))
          }

          ggplotList <- list()
          ## Plot a multi-facet ggplot for all gtSigNames and all runs.
          {
            ## Generate a ggplot object based on FinalAttr$AggManhattanDist$combined
            ggplotList$general <- ggplot2::ggplot(
              FinalAttr$AggManhattanDist$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value)) +
              ## Draw geom_violin and geom_quasirandom
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width",
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin plot
              ggplot2::ggtitle(label = "Scaled aggregated Manhattan distance between inferred and ground-truth",
                               subtitle = "exposures for all computational approaches, ratios and correlation values.") +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = "Scaled aggregated Manhattan distance") +
              ## Rotate the names of tools,
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_wrap(
                ggplot2::vars(gtSigName),
                ## Force facet_wrap to have 2 columns
                ncol = 2,
                scales = "free",
                ## Let facets be plotted vertically
                dir = "v"
              ) +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr$AggManhattanDist$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }
          ## Plot a multi-facet ggplot,
          ## facets are separated by gtSigNames and datasetGroup
          ## (in example, it refers to slope.)
          if(!is.null(OneToolSummary$datasetSubGroupName)) {
            bys <- c("datasetGroup","datasetSubGroup")
          } else {
            bys <- c("datasetGroup")
          }

          for(by in bys)  {

            ## The value of "datasetGroupName" or "datasetSubGroupName"
            ## which is the caption of "datasetGroup"
            byCaption <- eval(parse(
              text = paste0("OneToolSummary$",by,"Name")))


            ## Generate a ggplot object based on FinalAttr$AggManhattanDist$combined
            ggplotList[[by]] <- ggplot2::ggplot(
              FinalAttr$AggManhattanDist$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value))
            ## Draw geom_violin and geom_quasirandom
            ggplotList[[by]] <- ggplotList[[by]] +
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width"
                #,
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin plot
              ggplot2::ggtitle(
                label = paste0("Scaled aggregated Manhattan distance summary plot as a function of "),
                subtitle = paste0("ground-truth signature names and ",byCaption,".")) +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = "Scaled aggregated Manhattan distance") +
              ## Rotate the axis.text.x (names of tools),
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_grid(rows =  ggplot2::vars(gtSigName),
                                  cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
                                  scales = "free") +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr$AggManhattanDist$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }

          ## Plot violin plots in pdf format
          grDevices::pdf(paste0(out.dir,"/Aggregated.Scaled.Manhattan.Dist.violins.pdf"), pointsize = 1)
          for(by in names(ggplotList)){
            print(ggplotList[[by]])
          }
          grDevices::dev.off()
        }
      }


    }

    ## Summarizing results for mean and stdev of separated Manhattan distance
    if(flagExposure){

      fileNames = c(
        "meanSepMD" = "mean.of.sep.Scaled.Manhattan.dist",
        "sdSepMD" = "stdev.of.sep.Scaled.Manhattan.dist")
      titles = c(
        "meanSepMD" = "Mean of Manhattan distances of individual tumors",
        "sdSepMD" = "Standard deviation of Manhattan distances of individual tumors"
      )

      for(measure in c("meanSepMD", "sdSepMD"))
      {
        FinalAttr[[measure]] <- list()
        ## Combine attribution assessment onto multiple sheets.
        ## Each sheet shows Scaled Manhattan distance for one mutational signature.
        for(toolSummaryPath in toolSummaryPaths){
          ## Add OneToolSummary <- NULL to please R check
          OneToolSummary <- NULL
          load(paste0(toolSummaryPath,"/OneToolSummary.RDa"))

          if(length(FinalAttr[[measure]]) == 0){
            for(gtSigName in gtSigNames) {
              FinalAttr[[measure]][[gtSigName]] <- data.frame()
            }
          }

          ## Combine Scaled Manhattan distance
          for(gtSigName in gtSigNames){
            FinalAttr[[measure]][[gtSigName]] <- rbind(
              FinalAttr[[measure]][[gtSigName]],
              OneToolSummary[[measure]][[gtSigName]])
          }
        }

        ## For the purpose of SBS1-SBS5 paper,
        ## don't output summary tables for scaled Manhattan distance.
        if(FALSE){
          for(gtSigName in gtSigNames){
            output <- FinalAttr[[measure]][[gtSigName]]

            colnames(output)[1] <- "Seed or run number"
            colnames(output)[2] <- paste0("Scaled distance of ",gtSigName)
            colnames(output)[3] <- "Name of computational approach"
            colnames(output)[4] <- datasetGroupName
            colnames(output)[5] <- datasetSubGroupName

            write.csv(output,
                      file = paste0(out.dir,"/",fileNames[measure],".",gtSigName,".csv"))
          }
        }

        ## Plot general png and pdf for attribution Scaled Manhattan distance summary
        ## Plot a general violin plot for multiple signatures
        ## in all runs and in all datasets.
        {

          ## Combine all FinalAttr[[measure]][[gtSigName]] into FinalAttr[[measure]]$Combined
          FinalAttr[[measure]]$combined <- data.frame()
          for(gtSigName in gtSigNames){
            plotDFOneMeasure <- data.frame(FinalAttr[[measure]][[gtSigName]], gtSigName = gtSigName)
            FinalAttr[[measure]]$combined <- rbind(FinalAttr[[measure]]$combined,plotDFOneMeasure)
          }

          ## Convert FinalAttr[[measure]]$combined$datasetGroup and
          ## Let their levels follow gtools::mixedsort() fashion
          ## So that the order of the facet labels will be more reasonable for readers.
          FinalAttr[[measure]]$combined$datasetGroup <- factor(
            FinalAttr[[measure]]$combined$datasetGroup,
            levels = gtools::mixedsort(unique(FinalAttr[[measure]]$combined$datasetGroup)))

          if(!is.null(OneToolSummary$datasetSubGroupName)) {
            FinalAttr[[measure]]$combined$datasetSubGroup <- factor(
              FinalAttr[[measure]]$combined$datasetSubGroup,
              levels = gtools::mixedsort(unique(FinalAttr[[measure]]$combined$datasetSubGroup)))
          }

          ggplotList <- list()
          ## Plot a multi-facet ggplot for all gtSigNames and all runs.
          {
            ## Generate a ggplot object based on FinalAttr[[measure]]$combined
            ggplotList$general <- ggplot2::ggplot(
              FinalAttr[[measure]]$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value)) +
              ## Draw geom_violin and geom_quasirandom
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width",
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin plot
              ggplot2::ggtitle(label = titles[measure],
                               subtitle = " between inferred and ground-truth exposures.") +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = titles[measure]) +
              ## Rotate the names of tools,
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_wrap(
                ggplot2::vars(gtSigName),
                ## Force facet_wrap to have 2 columns
                ncol = 2,
                scales = "free",
                ## Let facets be plotted vertically
                dir = "v"
              ) +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr[[measure]]$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }
          ## Plot a multi-facet ggplot,
          ## facets are separated by gtSigNames and datasetGroup
          ## (in example, it refers to slope.)
          if(!is.null(OneToolSummary$datasetSubGroupName)) {
            bys <- c("datasetGroup","datasetSubGroup")
          } else {
            bys <- c("datasetGroup")
          }

          for(by in bys)  {

            ## The value of "datasetGroupName" or "datasetSubGroupName"
            ## which is the caption of "datasetGroup"
            byCaption <- eval(parse(
              text = paste0("OneToolSummary$",by,"Name")))


            ## Generate a ggplot object based on FinalAttr[[measure]]$combined
            ggplotList[[by]] <- ggplot2::ggplot(
              FinalAttr[[measure]]$combined,
              ggplot2::aes(x = .data$toolName, y = .data$value))
            ## Draw geom_violin and geom_quasirandom
            ggplotList[[by]] <- ggplotList[[by]] +
              ggplot2::geom_violin(
                ## Change filling color to white
                fill = "#FFFFFF",
                #ggplot2::aes(fill = gtSigName),
                ## Maximize the violin plot width
                scale = "width"
                #,
                ## Make bandwidth larger
                #position = "dodge",
                #width = 1.2
                ## Hide outliers
                #outlier.shape = NA
              ) +
              ## Show median of the Scaled Manhattan distance distribution
              ggplot2::stat_summary(fun="median", geom="point", shape = 21, fill = "red") +
              ## Show mean of the extraction meaasure distribution, as a blue diamond.
              ggplot2::stat_summary(fun="mean", geom="point", shape=23, fill="blue") +
              ## Add title for general violin plot
              ggplot2::ggtitle(
                label = paste0(titles[measure]," as a function of "),
                subtitle = paste0("ground-truth signature names and ",byCaption,".")) +
              ## Change axis titles
              ggplot2::labs(x = "Computational approach",
                            y = titles[measure]) +
              ## Rotate the axis.text.x (names of tools),
              ## move axis.text.x right below the tick marks
              ## and remove legends
              ggplot2::theme(axis.text.x = ggplot2::element_text(
                ## Rotate the axis.text.x (names of tools),
                angle = 90,
                ## move axis.text.x right below the tick marks
                hjust = 1, vjust = 0.5),
                ## remove legends.
                legend.position = "none") +
              ## Split the plot into multiple facets,
              ## according to different gtSigNames
              ggplot2::facet_grid(rows =  ggplot2::vars(gtSigName),
                                  cols = eval(parse(text = paste0("ggplot2::vars(",by,")"))),
                                  scales = "free") +
              ## Restrict the decimal numbers of values of measures to be 2
              ggplot2::scale_y_continuous(
                ## For scaled Manhattan distance, set ylim from 0 to the maximum of Manhattan distance value
                limits = c(0, max(FinalAttr[[measure]]$combined$value)),
                labels =function(x) sprintf("%.2f", x))
          }

          ## Plot violin plots in pdf format
          grDevices::pdf(paste0(out.dir,"/",fileNames[measure],".pdf"), pointsize = 1)
          for(by in names(ggplotList)){
            print(ggplotList[[by]])
          }
          grDevices::dev.off()
        }
      }

    }



    FinalSummary <- list()
    FinalSummary$FinalExtr <- FinalExtr
    if(flagExposure) {
      FinalSummary$FinalAttr <- FinalAttr
    }

    save(FinalSummary,file = paste0(out.dir,"/FinalSummary.RDa"))

    invisible(FinalSummary)
  }

